devtools::as.package()
devtools::load_all()
library(spatstat.geom)
# Non-square grid so nx != ny (this is key to surface the bug)
nx <- 4
ny <- 3
bin_param <- c(nx, ny)
#########################################################################
# tests/test-square-indexing.R
library(spatstat.geom)
nx <- 4
ny <- 3
bin_param <- c(nx, ny)
# Build window and tessellation consistent with quadratcount() usage
W <- owin(xrange = c(0, nx), yrange = c(0, ny))
# We'll use quadratcount() to define the reference binning and ordering
Q <- quadratcount(ppp(x = c(W$xrange[1], W$xrange[2]),
y = c(W$yrange[1], W$yrange[2]),
window = W),
nx = nx, ny = ny)
TESS <- as.tess(Q)
TESS
Q
ix_seq <- rep(1:nx, times = ny)
iy_seq <- rep(ny:1, each = nx)  # flipped y to match their convention
pts_x <- ix_seq - 0.5
pts_y <- iy_seq - 0.5
expected <- as.vector(t(quadratcount(ppp(pts_x, pts_y, window = W),
nx = nx, ny = ny))
expected
# IMPORTANT: iy runs "top to bottom" in the package code due to the y-flip.
ix_seq <- rep(1:nx, times = ny)
iy_seq <- rep(ny:1, each = nx)  # flipped y to match their convention
pts_x <- ix_seq - 0.5
pts_y <- iy_seq - 0.5
# Expected vector (ground truth) from spatstat in the same order
expected <- as.vector(t(quadratcount(ppp(pts_x, pts_y, window = W),
nx = nx, ny = ny)))
expected
# Build window and tessellation consistent with quadratcount() usage
W <- owin(xrange = c(0, nx), yrange = c(0, ny))
# We'll use quadratcount() to define the reference binning and ordering
Q <- quadratcount(ppp(x = c(W$xrange[1], W$xrange[2]),
y = c(W$yrange[1], W$yrange[2]),
window = W),
nx = nx, ny = ny)
TESS <- as.tess(Q)
# Create one point at the center of each bin.
# IMPORTANT: iy runs "top to bottom" in the package code due to the y-flip.
ix_seq <- rep(1:nx, times = ny)
iy_seq <- rep(ny:1, each = nx)  # flipped y to match their convention
pts_x <- ix_seq - 0.5
pts_y <- iy_seq - 0.5
# Expected vector (ground truth) from spatstat in the same order
expected <- as.vector(t(quadratcount(ppp(pts_x, pts_y, window = W),
nx = nx, ny = ny)))
ix_idx <- findInterval(pts_x, TESS$xgrid,
all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- findInterval(pts_y, TESS$ygrid,
all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- ny + 1 - iy_idx
# BUGGY linear index (uses ny instead of nx):
ind_bug <- (iy_idx - 1) * ny + ix_idx
ind_bug
ind_fix <- (iy_idx - 1) * nx + ix_idx
ind_fix
pts_x
expected
vec_bug <- integer(nx * ny); vec_bug[ind_bug] <- vec_bug[ind_bug] + 1L
vec_fix <- integer(nx * ny); vec_fix[ind_fix] <- vec_fix[ind_fix] + 1L
# Non-square grid so nx != ny (this triggers the bug)
nx <- 4
ny <- 3
bin_param <- c(nx, ny)
# Build a reference window and a tessellation whose ordering matches
# as.vector(t(quadratcount(...))) used elsewhere
W <- owin(xrange = c(0, nx), yrange = c(0, ny))
Q <- quadratcount(ppp(x = c(W$xrange[1], W$xrange[2]),
y = c(W$yrange[1], W$yrange[2]),
window = W),
nx = nx, ny = ny)
TESS <- as.tess(Q)
# For each bin (1..nx*ny), place 'k' points IN THAT BIN.
# We'll place points at bin centers. The ordering of bins in expected is:
# expected <- as.vector(t(quadratcount(...)))
# So we generate centers in that same order.
ix_seq <- rep(1:nx, times = ny)       # x-bin index increases fastest
iy_seq <- rep(ny:1, each = nx)        # y-flip to match code’s convention
cx <- ix_seq - 0.5
cy <- iy_seq - 0.5
# For bin k, repeat its center k times.
reps <- seq_len(nx * ny)
pts_x <- rep(cx, times = reps)
pts_y <- rep(cy, times = reps)
pts_x
# Grid: nx=3 (x bins), ny=4 (y bins)  → 12 bins total
nx <- 3; ny <- 4
bin_param <- c(nx, ny)
# Window and reference binning (ordering matches as.vector(t(quadratcount(...))))
W <- owin(xrange = c(0, nx), yrange = c(0, ny))
Qref <- quadratcount(ppp(x = c(W$xrange[1], W$xrange[2]),
y = c(W$yrange[1], W$yrange[2]),
window = W),
nx = nx, ny = ny)
TESS <- as.tess(Qref)
pts <- function(ix, iy, n) {
cbind(x = rep(ix - 0.5, n), y = rep(iy - 0.5, n))
}
P <- rbind(
pts(1, 4, 2),
pts(2, 2, 3),
pts(3, 1, 1)
)
px <- P[,1]; py <- P[,2]
px
# Ground truth from spatstat (this is the correct bin-count vector)
expected <- as.vector(t(quadratcount(ppp(px, py, window = W), nx = nx, ny = ny)))
pts <- function(ix, iy, n, threshold) {
cbind(x = rep(ix - threshold, n), y = rep(iy - threshold, n))
}
P <- rbind(
pts(1, 4, 1, 0.5),
pts(1, 4, 1, 0.3),
pts(2, 2, 1, 0.3),
pts(2, 2, 1, 0.2),
pts(2, 2, 1, 0.4),
pts(3, 1, 1, 0.5)
)
px <- P[,1]; py <- P[,2]
# Ground truth from spatstat (this is the correct bin-count vector)
expected <- as.vector(t(quadratcount(ppp(px, py, window = W), nx = nx, ny = ny)))
expected
# --- Emulate package's manual path (findInterval + y-flip + linear index) ---
ix_idx <- findInterval(px, TESS$xgrid, all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- findInterval(py, TESS$ygrid, all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- ny + 1 - iy_idx  # flip y to match code's convention
ind_bug <- (iy_idx - 1) * ny + ix_idx
# FIXED linear index (uses nx):
ind_fix <- (iy_idx - 1) * nx + ix_idx
# Accumulate counts
vec_bug <- integer(nx * ny); vec_bug[ind_bug] <- vec_bug[ind_bug] + 1L
vec_bug
skip_if_not_installed("spatstat.geom")
library(spatstat.geom)
# Grid: nx=3 (x bins), ny=4 (y bins)  → 12 bins total
nx <- 3; ny <- 4
bin_param <- c(nx, ny)
# Window and reference binning (ordering matches as.vector(t(quadratcount(...))))
W <- owin(xrange = c(0, nx), yrange = c(0, ny))
Qref <- quadratcount(ppp(x = c(W$xrange[1], W$xrange[2]),
y = c(W$yrange[1], W$yrange[2]),
window = W),
nx = nx, ny = ny)
TESS <- as.tess(Qref)
# --- Place a FEW points, with explicit counts per bin ---
# We'll use bin centers (ix - 0.5, iy - 0.5).
# NOTE: 'iy' here is in the "top→bottom" convention used by the package's flip:
#   iy = ny is the TOP row, iy = 1 is the BOTTOM row.
#
# Put:
# - 2 points in bin (ix=1, iy=4)  [top-left]
# - 3 points in bin (ix=2, iy=2)  [middle]
# - 1 point  in bin (ix=3, iy=1)  [bottom-right]
# (2, 0, 0, 0)
# (0, 3, 0, 0)
# (0, 0, 0, 1)
pts <- function(ix, iy, n, threshold) {
cbind(x = rep(ix - threshold, n), y = rep(iy - threshold, n))
}
P <- rbind(
pts(1, 4, 1, 0.5),
pts(1, 4, 1, 0.3),
pts(2, 2, 1, 0.3),
pts(2, 2, 1, 0.2),
pts(2, 2, 1, 0.4),
pts(3, 1, 1, 0.5)
)
px <- P[,1]; py <- P[,2]
# Ground truth from spatstat (this is the correct bin-count vector)
expected <- as.vector(t(quadratcount(ppp(px, py, window = W), nx = nx, ny = ny)))
# For clarity, expected counts per bin (in spatstat's order):
# Matrix Q (ny rows x nx cols), then as.vector(t(Q)) flattens by rows of t(Q)
# You can uncomment to see it during dev:
# print(matrix(expected, nrow = 1))
# --- Emulate package's manual path (findInterval + y-flip + linear index) ---
ix_idx <- findInterval(px, TESS$xgrid, all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- findInterval(py, TESS$ygrid, all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- ny + 1 - iy_idx  # flip y to match code's convention
# BUGGY linear index (uses ny):
ind_bug <- (iy_idx - 1) * ny + ix_idx
# FIXED linear index (uses nx):
ind_fix <- (iy_idx - 1) * nx + ix_idx
# Accumulate counts
vec_bug <- integer(nx * ny); vec_bug[ind_bug] <- vec_bug[ind_bug] + 1L
vec_fix <- integer(nx * ny); vec_fix[ind_fix] <- vec_fix[ind_fix] + 1L
vec_bug
vec_fix
expected <- as.vector(t(quadratcount(ppp(px, py, window = W), nx = nx, ny = ny)))
# For clarity, expected counts per bin (in spatstat's order):
# Matrix Q (ny rows x nx cols), then as.vector(t(Q)) flattens by rows of t(Q)
# You can uncomment to see it during dev:
# print(matrix(expected, nrow = 1))
# --- Emulate package's manual path (findInterval + y-flip + linear index) ---
ix_idx <- findInterval(px, TESS$xgrid, all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- findInterval(py, TESS$ygrid, all.inside = TRUE, left.open = FALSE, rightmost.closed = TRUE)
iy_idx <- ny + 1 - iy_idx  # flip y to match code's convention
# BUGGY linear index (uses ny):
ind_bug <- (iy_idx - 1) * ny + ix_idx
# FIXED linear index (uses nx):
ind_fix <- (iy_idx - 1) * nx + ix_idx
# Accumulate counts
vec_bug <- integer(nx * ny); vec_bug[ind_bug] <- vec_bug[ind_bug]
vec_fix <- integer(nx * ny); vec_fix[ind_fix] <- vec_fix[ind_fix]
vec_fix
ind_bug
TESS$xgrid
ix_idx
ix <- findInterval(px$x, tess$xgrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
px
iy <- findInterval(py, tess$ygrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
ix <- findInterval(px, TESS$xgrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
iy <- findInterval(py, TESS$ygrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
# column major
iy <- bin_param[2] + 1 - iy  # flip y for column-major order
ind_vec <- (iy - 1) * bin_param[2] + ix
cluster_info$index_vec[cluster_info$sample == rp_nm] <- ind_vec # flip y to match code's convention
ind_vec
expected
# FIXED linear index (uses nx):
ind_fix <- (iy- 1) * nx + ix
ind_fix
ix <- findInterval(px, TESS$xgrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
iy <- findInterval(py, TESS$ygrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
# column major
iy <- ny + 1 - iy  # flip y for column-major order
ind_vec <- (iy - 1) * bin_param[2] + ix
ind_vec
# print(matrix(expected, nrow = 1))
# --- Emulate package's manual path (findInterval + y-flip + linear index) ---
ix <- findInterval(px, TESS$xgrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
iy <- findInterval(py, TESS$ygrid,
all.inside = TRUE,
left.open = FALSE,
rightmost.closed = TRUE)
# column major
iy <- ny + 1 - iy  # flip y for column-major order
ind_vec <- (iy - 1) * ny+ ix
ind_vec
expected
# BUGGY linear index (uses ny):
ind_bug <- (iy - 1) * ny + ix
ind_bug
ind_fix <- (iy- 1) * nx + ix
ind_fix
(iy- 1) * nx + ix
(iy - 1) * ny + ix
cbind(x= px, y = py, smaple="samople1")
px
paste(px, collapse = ",")
py
cluster_info = as.data.frame(cbind(x = c(0.5,0.7,1.7,1.8,1.6,2.5),
y=c(3.5,3.7,1.7,1.8,1.6,0.5),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
cm = matrix(c(1,2,3,1,2,3), nrow=2, ncol=3)
colnames(cm) = c("cell1", "cell2","cell3")
row.names(cm) = c("geneA","geneB")
se = SingleCellExperiment(cm)
sv_lst = get_vectors(x=se, cluster_info = cluster_info, bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
sv_lst = get_vectors(x=cm, cluster_info = cluster_info, bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
sv_lst = get_vectors(x=cm, cluster_info = cluster_info,
sample_names=c("sample1"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
sv_lst = get_vectors(x=cm, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB")
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
sv_lst = get_vectors(x=cm, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
library(SingleCellExperiment)
library(SpatialExperiment)
library(SpatialFeatureExperiment)
library(SFEData)
library(Matrix)
library(BumpyMatrix)
cluster_info = as.data.frame(cbind(x = c(0,0.7,1.7,1.8,1.6,3),
y=c(4,3.7,1.7,1.8,1.6,0),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
cm = matrix(c(1,2,3,1,2,3), nrow=2, ncol=3)
colnames(cm) = c("cell1", "cell2","cell3")
row.names(cm) = c("geneA","geneB")
se = SingleCellExperiment(cm)
sv_lst = get_vectors(x=cm, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
sv_lst = get_vectors(x=se, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
se = SingleCellExperiment(cm,sampel_id = "sample1")
se = SingleCellExperiment(cm,sample = "sample1")
se = SingleCellExperiment(lsit(sample1 = cm))
se = SingleCellExperiment(list(sample1 = cm))
sv_lst = get_vectors(x=se, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
cluster_info = as.data.frame(cbind(x = c(0,0.7,1.7,1.8,1.6,3),
y=c(4,3.7,1.7,1.8,1.6,0),
cluster = c("c1", "c2","c3","c2","c2","c2"),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
cm = matrix(c(1,2,3,1,2,3), nrow=2, ncol=3)
colnames(cm) = c("cell1", "cell2","cell3")
row.names(cm) = c("geneA","geneB")
se = SingleCellExperiment(list(sample1 = cm))
sv_lst = get_vectors(x=se, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
devtools::load_all()
cluster_info = as.data.frame(cbind(x = c(0,0.7,1.7,1.8,1.6,3),
y=c(4,3.7,1.7,1.8,1.6,0),
cluster = c("c1", "c2","c3","c2","c2","c2"),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
cluster_info$x = as.numeric(cluster_info$x)
cluster_info$y = as.numeric(cluster_info$y)
cm = matrix(c(1,2,3,1,2,3), nrow=2, ncol=3)
colnames(cm) = c("cell1", "cell2","cell3")
row.names(cm) = c("geneA","geneB")
se = SingleCellExperiment(list(sample1 = cm))
sv_lst = get_vectors(x=se, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle", use_cm=TRUE)
expect_equal(sv_lst$cluster_mt[,"c1"], c(1,0,0,0,0,0,0,0,0,0,0,0))
sv_lst$cluster_mt[,"c1"]
expect_equal(sv_lst$cluster_mt[,"c3"], c(0,0,0,0,0,1,0,0,0,0,0,0))
cluster_info = as.data.frame(cbind(x = c(0,0.7,1.7,1.8,1.6,3),
y=c(4,3.7,1.7,1.8,1.6,0),
cluster = c("c1", "c2","c3","c2","c2","c2"),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
#(2, 0, 0, 0)
#(0, 3, 0, 0)
#(0, 0, 0, 1)
sv_lst$cluster_mt[,"c3"]
cluster_info = as.data.frame(cbind(x = c(0, 0.7, 1.7, 1.8, 1.6, 3),
y = c(4, 3.7, 1.7, 1.8, 1.6, 0),
cluster = c("c1", "c2","c3","c2","c2","c2"),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
#(2, 0, 0, 0)
#(0, 3, 0, 0)
#(0, 0, 0, 1)
cluster_info$x = as.numeric(cluster_info$x)
cluster_info$y = as.numeric(cluster_info$y)
cm = matrix(c(1,2,3,1,2,3), nrow=2, ncol=3)
colnames(cm) = c("cell1", "cell2","cell3")
row.names(cm) = c("geneA","geneB")
se = SingleCellExperiment(list(sample1 = cm))
sv_lst = get_vectors(x=se, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle",
use_cm=TRUE)
sv_lst$cluster_mt[,"c3"]
devtools::document()
devtools::load_all()
cluster_info = as.data.frame(cbind(x = c(0, 0.7, 1.7, 1.8, 1.6, 3),
y = c(4, 3.7, 1.7, 1.8, 1.6, 0),
cluster = c("c1", "c2","c3","c2","c2","c2"),
cell_id = c("cell1", "cell1", "cell2","cell3", "cell3","cell3"),
sample="sample1"))
#(2, 0, 0, 0)
#(0, 3, 0, 0)
#(0, 0, 0, 1)
cluster_info$x = as.numeric(cluster_info$x)
cluster_info$y = as.numeric(cluster_info$y)
cm = matrix(c(1,2,3,1,2,3), nrow=2, ncol=3)
colnames(cm) = c("cell1", "cell2","cell3")
row.names(cm) = c("geneA","geneB")
se = SingleCellExperiment(list(sample1 = cm))
sv_lst = get_vectors(x=se, cluster_info = cluster_info,
sample_names=c("sample1"),
test_genes=c("geneA", "geneB"),
bin_param = c(3,4),bin_type ="rectangle",
use_cm=TRUE)
sv_lst$cluster_mt[,"c3"]
# Set knitr chunk options for clean output
knitr::opts_chunk$set(
warning = FALSE,
message = FALSE,
fig.width = 10,
fig.height = 6,
dpi = 300
)
# Load required libraries
library(ggplot2)
library(patchwork)
library(SpatialExperiment)
library(corrplot)
library(CosMxSpatialAnalysisWorkshop)
library(jazzPanda)
library(SpatialExperiment)
library(pheatmap)
library(Seurat)
library(dplyr)
library(ComplexUpset)
# Set random seed for reproducibility
knitr::write_bib(c(
.packages(), 'knitr', 'rmarkdown', 'prettydoc'
), 'packages.bib')
seed_number <- 899
set.seed(seed_number)
# Define consistent ggplot theme for spatial plots
defined_theme <- theme(
strip.text = element_text(size = rel(1)),
strip.background = element_rect(fill = NA, colour = "black"),
axis.line = element_blank(),
axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
legend.position = "none",
panel.background = element_blank(),
panel.border = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank(),
plot.background = element_blank()
)
# Function to automatically determine hex bin size based on data density
auto_hex_bin <- function(n, target_points_per_bin = 5) {
k <- n / target_points_per_bin
bins <- round(sqrt(k))
return(max(10, bins))
}
# Load data
data(r1_sub_se)
data(r3_sub_se)
data(r1_tx)
data(r3_tx)
# Create cell information data frames
r1_cells = as.data.frame(cbind(
spatialCoords(r1_sub_se),
cell_id = paste0("Lung5_Rep1_", r1_sub_se$cell_id),
sample = r1_sub_se$sample_id,
cluster = r1_sub_se$cluster
))
# Load data
data(r1_sub_se)
data(r3_sub_se)
data(r1_tx)
data(r3_tx)
library(SpatialExperiment)
library(CosMxSpatialAnalysisWorkshop)
