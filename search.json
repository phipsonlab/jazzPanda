[{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"jazzPanda example","text":"Spatial transcriptomics allows spatial profiling complex tissue architectures. spatial arrangement interactions cells can aid understanding complex functions regulatory mechanisms various tissue micro environments. Commercially available image-based spatial technologies Xenium, CosMX, MERSCOPSE take advantage fluorescence-based microscopy quantify transcripts focus pre-designed panel genes. One crucial step analysis spatial transcriptomics data cell type annotation. number ways perform cell type annotation, marker analysis one . Marker gene analysis identify genes highly expressed cluster compared remaining clusters. identified marker genes used annotate clusters cell types. Computationally tools originally developed single cell data used spatial transcriptomics studies. However, methods ignore spatial information cells gene. limited literature developing marker gene detection methods account spatial distribution gene expression. jazzPanda provides two novel approaches detect marker genes transformed spatial information. first approach based correlation second linear modelling approach can account technical noise work studies multiple samples.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"jazzpanda-framework","dir":"Articles","previous_headings":"","what":"jazzPanda framework","title":"jazzPanda example","text":"assume marker gene show significant linear relationship target cluster tissue space. suggests transcript detection marker gene show similar patterns cells cluster tissue space. Given cluster label every cell, two steps obtain marker genes every cluster. first compute spatial vectors spatial coordinates genes clusters. , can measure linear relationship genes clusters based spatial vectors. develop two approaches detecting genes show strong linear relationship cluster. Step 1: Create spatial vectors every gene every clusterget_vectors() can used convert transcript detection cell centroids spatial vectors. can specify tile shape length based dataset. hex bins generally take longer square/rectangle bins compute. practice, find can choose length tiles average cell per tile (# cells per cluster# tiles\\frac{\\texttt{\\#}\\text{ cells per cluster} }{\\texttt{\\#}\\text{ tiles}}) close one cluster. Step 2: Detect marker genes Correlation approach: compute_permp() approach can detect marker genes one sample study. calculate correlation coefficient every pair gene cluster vector. perform permutation testing assess statistical significance calculated correlation followed multiple testing adjustment control false discovery rate. keep genes significant adjusted p-value large correlation marker genes. practice, recommend calculate correlation threshold value every cluster based data distribution. analysis, use 75% quantile value correlations given cluster cutoff manage keep meaningful marker genes. Linear modelling approach: lasso_markers() approach, treat gene vector response variable cluster vectors explanatory variables. select important cluster vectors lasso regularization first, fit linear model find cluster show minimum p-value largest model coefficient. approach can account multi-sample studies technical background noise (non-specific binding). recommend set model coefficient cutoff value based data. large cutoff value result fewer marker genes whereas small cutoff value detect marker genes. find cutoff value 0.1 0.2 work well analysis. Marker genes less 0.1 model coefficient generally weak markers. Two data frames returned approach: record significant cluster gene calling get_top_mg() function. table provides unique marker genes every cluster. Genes whose top cluster shows model coefficient smaller specified cutoff value labeled marker genes. record significant cluster gene using function get_full_mg(). table can used investigate shared marker genes different clusters.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"jazzPanda example","text":"dataset used vignette selected subset two replicates Xenium human breast cancer tissue Sample 1. select 20 genes package illustration. subset extracted raw dataset described R script located system.file(\"script\",\"generate_vignette_data.R\", package=\"jazzPanda\"). subset data used package illustration purpose . resulting marker genes may strong markers annotating clusters. Please see full analysis dataset marker genes.","code":"library(jazzPanda) library(SpatialExperiment) library(ggplot2) library(grid) library(data.table) library(dplyr) library(glmnet) library(caret) library(corrplot) library(igraph) library(ggraph) library(ggrepel) library(gridExtra) library(utils) library(spatstat) library(tidyr) library(ggpubr) # ggplot style defined_theme <- theme(strip.text = element_text(size = rel(1)),                         strip.background = element_rect(fill = NA,                                                      colour = \"black\"),                         axis.line=element_blank(),                         axis.text.x=element_blank(),                         axis.text.y=element_blank(),                         axis.ticks=element_blank(),                         axis.title.x=element_blank(),                         axis.title.y=element_blank(),                         legend.position=\"none\",                         panel.background=element_blank(),                         panel.border=element_blank(),                         panel.grid.major=element_blank(),                         panel.grid.minor=element_blank(),                         plot.background=element_blank())"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"load-data","dir":"Articles","previous_headings":"Example","what":"Load data","title":"jazzPanda example","text":"","code":"data(rep1_sub, rep1_clusters, rep1_neg) rep1_clusters$cluster<-factor(rep1_clusters$cluster,                             levels=paste(\"c\",1:8, sep=\"\")) # record the transcript coordinates for rep1 rep1_transcripts <-BumpyMatrix::unsplitAsDataFrame(molecules(rep1_sub)) rep1_transcripts <- as.data.frame(rep1_transcripts) colnames(rep1_transcripts) <- c(\"feature_name\",\"cell_id\",\"x\",\"y\") # record the negative control transcript coordinates for rep1 rep1_nc_data <- BumpyMatrix::unsplitAsDataFrame(molecules(rep1_neg)) rep1_nc_data <- as.data.frame(rep1_nc_data) colnames(rep1_nc_data) <- c(\"feature_name\",\"cell_id\",\"x\",\"y\",\"category\")  # record all real genes in the data all_real_genes <- unique(as.character(rep1_transcripts$feature_name)) all_celltypes <- unique(rep1_clusters[,c(\"anno\",\"cluster\")])"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-the-clusters-over-the-tissue-space","dir":"Articles","previous_headings":"Example","what":"Visualise the clusters over the tissue space","title":"jazzPanda example","text":"can plot cells coordinates cluster Replicate 1 subset","code":"p1<-ggplot(data = rep1_clusters,         aes(x = x, y = y, color=cluster))+         geom_point(position=position_jitterdodge(jitter.width=0,                                         jitter.height=0), size=0.1)+         scale_y_reverse()+         theme_classic()+         facet_wrap(~sample)+         scale_color_manual(values = c(\"#FC8D62\",\"#66C2A5\" ,\"#8DA0CB\",\"#E78AC3\",                         \"#A6D854\",\"skyblue\",\"purple3\",\"#E5C498\"))+         guides(color=guide_legend(title=\"cluster\", nrow = 2,                         override.aes=list(alpha=1, size=2)))+                  theme(axis.text.x=element_blank(),                 axis.text.y=element_blank(),                 axis.ticks=element_blank(),                 panel.spacing = grid::unit(0.5, \"lines\"),                 axis.title.x=element_blank(),                 axis.title.y=element_blank(),                 legend.position=\"none\",                 strip.text = element_text(size = rel(1)))+         xlab(\"\")+         ylab(\"\") p2<-ggplot(data = rep1_clusters,         aes(x = x, y = y, color=cluster))+         geom_point(position=position_jitterdodge(jitter.width=0,                                      jitter.height=0), size=0.1)+         facet_wrap(~cluster, nrow = 2)+         scale_y_reverse()+         theme_classic()+         scale_color_manual(values = c(\"#FC8D62\",\"#66C2A5\" ,\"#8DA0CB\",\"#E78AC3\",                         \"#A6D854\",\"skyblue\",\"purple3\",\"#E5C498\"))+         guides(color=guide_legend(title=\"cluster\", nrow = 1,         override.aes=list(alpha=1, size=4)))+         theme(axis.text.x=element_blank(),             axis.text.y=element_blank(),             axis.ticks=element_blank(),             axis.title.x=element_blank(),             axis.title.y=element_blank(),             panel.spacing = grid::unit(0.5, \"lines\"),              legend.text = element_text(size=10),             legend.position=\"none\",             legend.title = element_text(size=10),             strip.text = element_text(size = rel(1)))+         xlab(\"\")+         ylab(\"\")  spacer <- patchwork::plot_spacer() layout_design <- (p1 / spacer) | p2  layout_design <- layout_design +                      patchwork::plot_layout(widths = c(1, 4), heights = c(1, 1))   print(layout_design)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"spatial-vectors","dir":"Articles","previous_headings":"Example","what":"Spatial vectors","title":"jazzPanda example","text":"can visualize spatial vectors clusters genes follows. example creating spatial vectors genes, plot transcript detections gene EPCAM tissue space, along square hex binning result. Similarly, plot cell coordinates cluster c1, well square hex bin values space example. can see square hex bins capture key patterns original coordinates. Hex bins can capture details square bins.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"example-of-gene-vectors-from-scratch","dir":"Articles","previous_headings":"Example > Spatial vectors","what":"Example of gene vectors from scratch","title":"jazzPanda example","text":"","code":"w_x <- c(min(floor(min(rep1_transcripts$x)),         floor(min(rep1_clusters$x))),          max(ceiling(max(rep1_transcripts$x)),         ceiling(max(rep1_clusters$x)))) w_y <- c(min(floor(min(rep1_transcripts$y)),         floor(min(rep1_clusters$y))),          max(ceiling(max(rep1_transcripts$y)),         ceiling(max(rep1_clusters$y))))  # plot transcript detection coordinates selected_genes <- rep1_transcripts$feature_name == \"EPCAM\" loc_mt <- as.data.frame(rep1_transcripts[selected_genes,                         c(\"x\",\"y\",\"feature_name\")]%>%distinct()) colnames(loc_mt)<-c(\"x\",\"y\",\"feature_name\") layout(matrix(c(1, 2, 3), 1, 3, byrow = TRUE)) par(mar=c(5,3,6,3)) plot(loc_mt$x, loc_mt$y, main = \"\", xlab = \"\", ylab = \"\",          pch = 20, col = \"maroon4\", cex = 0.1,xaxt='n', yaxt='n')    title(main = \"EPCAM transcript detection\", line = 3) box()   # plot square binning  curr<-loc_mt[loc_mt[,\"feature_name\"]==\"EPCAM\",c(\"x\",\"y\")] %>% distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, 10,10) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.01,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"square binning\", line = -2)  # plot hex binning  w <- owin(xrange=w_x, yrange=w_y) H <- hextess(W=w, 20) bin_length <- length(H$tiles) curr<-loc_mt[loc_mt[,\"feature_name\"]==\"EPCAM\",c(\"x\",\"y\")] %>% distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, tess=H) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.1,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"hex binning\", line = -2)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"example-of-cluster-vectors-from-scratch","dir":"Articles","previous_headings":"Example > Spatial vectors","what":"Example of cluster vectors from scratch","title":"jazzPanda example","text":"function get_vectors() can used create spatial vectors genes clusters. spatial vectors may take form squares, rectangles, hexagons specified bin_type parameter. ### Create spatial vectors genes clusters fucntion get_vector() now automatically detects bounding box define spatial vectors. makes robust scenarios different samples different spatial extents (e.g., one sample much larger another). want define gene vectors transcript coordinates, cell transcript coordinates must coordinate frame scale (units, origin). aren’t, transform/rescale one match calling get_vector() constructed spatial vectors can used quantify cluster-cluster gene-gene correlation. #### Cluster-Cluster correlation","code":"w_x <- c(min(floor(min(rep1_transcripts$x)),             floor(min(rep1_clusters$x))),          max(ceiling(max(rep1_transcripts$x)),             ceiling(max(rep1_clusters$x)))) w_y <-  c(min(floor(min(rep1_transcripts$y)),             floor(min(rep1_clusters$y))),          max(ceiling(max(rep1_transcripts$y)),             ceiling(max(rep1_clusters$y))))  # plot cell coordinates loc_mt <- as.data.frame(rep1_clusters[rep1_clusters$cluster==\"c1\",             c(\"x\",\"y\",\"cluster\")]) colnames(loc_mt)=c(\"x\",\"y\",\"cluster\") layout(matrix(c(1, 2, 3), 1, 3, byrow = TRUE)) par(mar=c(5,3,6,3)) plot(loc_mt$x, loc_mt$y, main = \"\", xlab = \"\", ylab = \"\",          pch = 20, col = \"maroon4\", cex = 0.1,xaxt='n', yaxt='n')    title(main = \"cell coordinates in cluster c1\", line = 3) box()   # plot square binning  curr<-loc_mt[loc_mt[,\"cluster\"]==\"c1\", c(\"x\",\"y\")]%>%distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, 10,10) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.1,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"square binning\", line = -2)  # plot hex binning  w <- owin(xrange=w_x, yrange=w_y) H <- hextess(W=w, 20) bin_length <- length(H$tiles) curr<-loc_mt[loc_mt[,\"cluster\"]==\"c1\",c(\"x\",\"y\")] %>%distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, tess=H) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.1,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"hex binning\", line = -2) seed_number<- 589  grid_length <- 10 # get spatial vectors rep1_sq10_vectors <- get_vectors(x= rep1_sub,                                 sample_names = \"rep1\",                                 cluster_info = rep1_clusters,                                 bin_type=\"square\",                                 bin_param=c(grid_length,grid_length),                                  test_genes = all_real_genes) seed_number<- 589 grid_length <- 10  # get spatial vectors for clusters only cluster_sq10_vectors <- get_vectors(x= NULL,                                 sample_names = \"rep1\",                                 cluster_info = rep1_clusters,                                 bin_type=\"square\",                                 bin_param=c(grid_length,grid_length),                                  test_genes = all_real_genes) # the gene vectors can be accessed as: head(cluster_sq10_vectors$cluster_mt) ##      c5 c8 c3 c2 c1 c4 c6 c7 ## [1,]  0  2  1  0  7  1  0  1 ## [2,]  0  1  1  0  6  0  0  0 ## [3,]  0  0  3  0 13  1  0  0 ## [4,]  0  0  4  0  2  3  2  1 ## [5,]  0  0  1  0  0  7  9  2 ## [6,]  0  0  3  0  0  3  3  2 # cluster_sq10_vectors$cluster_mt is equivalent to rep1_sq10_vectors$cluster_mt  ####################################################### # get spatial vectors for genes only  gene_sq10_vectors <- get_vectors(x= rep1_sub,                                 sample_names = \"rep1\",                                 cluster_info = NULL,                                 bin_type=\"square\",                                 bin_param=c(grid_length,grid_length),                                  test_genes = all_real_genes) # the gene vectors can be accessed as: head(gene_sq10_vectors$gene_mt) ##      CD68 DST EPCAM ERBB2 FOXA1 KRT7 LUM MYLK PECAM1 PTPRC SERPINA3 AQP1 VWF ## [1,]    9   9    34    76    34   68  13    2      7     3        6    5   2 ## [2,]    4  21   101   170    72  107  34    7     10     2        2   10  10 ## [3,]    6  23   146   249   113  147  25    2      0     0        3    3   5 ## [4,]   14   6    50   153    71  103  81    0      3    16        0    1   1 ## [5,]   28   7    10    45    16   21  20    0      8    52        2    1   1 ## [6,]   21   3     7    46    24    5  39    3     12    21       13    4   0 ##      CCDC80 ITM2C POSTN FGL2 MZB1 IL7R LYZ ## [1,]     13    20    30    4    4    1  12 ## [2,]     21     4    38    2    2    7   6 ## [3,]     12     4    15    0    1    1   3 ## [4,]     23    17    67    5    7   12   9 ## [5,]      6    26    18   41   11   33  57 ## [6,]     36    21    52   27   13   34  30 # gene_sq10_vectors$gene_mt is equivalent to rep1_sq10_vectors$gene_mt exp_ord <- paste(\"c\", 1:8, sep=\"\") rep1_sq10_vectors$cluster_mt <- rep1_sq10_vectors$cluster_mt[,exp_ord] cor_cluster_mt <- cor(rep1_sq10_vectors$cluster_mt,                 rep1_sq10_vectors$cluster_mt, method = \"pearson\") # Calculate pairwise correlations cor_gene_mt <- cor(rep1_sq10_vectors$gene_mt, rep1_sq10_vectors$gene_mt,                     method = \"pearson\")  col <- grDevices::colorRampPalette(c(\"#4477AA\", \"#77AADD\",                                      \"#FFFFFF\",\"#EE9988\", \"#BB4444\"))  corrplot::corrplot(cor_cluster_mt, method=\"color\", col=col(200), diag=TRUE,                 addCoef.col = \"black\",type=\"upper\",                 tl.col=\"black\", tl.srt=45, mar=c(0,0,5,0),sig.level = 0.05,                  insig = \"blank\",                  title = \"cluster-cluster correlation (square bin = 40x40)\"                 )"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"gene-cluster-correlation","dir":"Articles","previous_headings":"Example > Spatial vectors > Example of cluster vectors from scratch","what":"Gene-Cluster correlation","title":"jazzPanda example","text":"can also construct gene network based spatial vector genes.","code":"cor_genecluster_mt <- cor(x=rep1_sq10_vectors$gene_mt,                          y=rep1_sq10_vectors$cluster_mt, method = \"pearson\")  gg_correlation <- as.data.frame(cbind(apply(cor_gene_mt, MARGIN=1,                                              FUN = mean, na.rm=TRUE),                                         apply(cor_genecluster_mt, MARGIN=1,                                              FUN = mean, na.rm=TRUE))) colnames(gg_correlation) <- c(\"mean_correlation\",\"mean_cluster\")   gg_correlation$gene<-row.names(gg_correlation)  plot(ggplot(data = gg_correlation,      aes(x= mean_correlation, y=mean_cluster))+         geom_point()+         geom_text_repel(aes(label=gg_correlation$gene), size=1.8, hjust=1)+     theme_bw()+     theme(legend.title=element_blank(),             axis.text.y = element_text(size=20),             axis.text.x = element_text(size=20),             axis.title.x=element_text(size=20),             axis.title.y=element_text(size=20),              panel.spacing = grid::unit(0.5, \"lines\"),              legend.position=\"none\",             legend.text=element_blank())+     xlab(\"Average gene-gene correlation\")+     ylab(\"Average gene-cluster correlation\"))"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"gene-network","dir":"Articles","previous_headings":"Example > Spatial vectors > Example of cluster vectors from scratch","what":"Gene network","title":"jazzPanda example","text":"","code":"vector_graph<- igraph::graph_from_adjacency_matrix(cor_gene_mt,                                                 mode = \"undirected\",                                                  weighted = TRUE,                                                  diag = FALSE)  vector_graph<-igraph::simplify(igraph::delete_edges(vector_graph,                          E(vector_graph)[abs(E(vector_graph)$weight) <= 0.7]))  layout<-igraph::layout_with_kk(vector_graph)  # Plot the graph ggraph::ggraph(vector_graph, layout = layout) +     geom_edge_link(aes(edge_alpha = weight), show.legend = FALSE) +     geom_node_point(color = \"lightblue\", size = 5) +     geom_node_text(aes(label = name),                      vjust = 1, hjust = 1,size=2,color=\"orange\", repel = TRUE)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"create-spatial-vectors-for-diverse-data-types","dir":"Articles","previous_headings":"Example > Spatial vectors","what":"Create spatial vectors for diverse data types","title":"jazzPanda example","text":"main function lasso_markers() requires spatial vectors cluster gene. vectors can conveniently generated using get_vectors() function. Currently, get_vectors() function supports inputs type list, SingleCellExperiment, SpatialExperiment, SpatialFeatureExperiment. following sections illustrate create spatial vectors genes clusters given different data objects .","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-list","dir":"Articles","previous_headings":"Example > Spatial vectors > Create spatial vectors for diverse data types","what":"From a list","title":"jazzPanda example","text":"named list can effectively utilized store transcript detection data sample. Specifically, create named list name corresponds different sample within data. element list dataframe containing columns: “feature_name” (gene name), “x” (x-coordinate), “y” (y-coordinate). crucial list names match sample identifiers cluster_info. approach highly recommended difficulties arise defining SpatialExperiment object data.","code":"seed_number<- 589 grid_length <- 10 # get spatial vectors rep1_sq10_vectors_lst <- get_vectors(x= list(\"rep1\" = rep1_transcripts),                                 sample_names = \"rep1\",                                 cluster_info = rep1_clusters,                                 bin_type=\"square\",                                 bin_param=c(grid_length,grid_length),                                  test_genes = all_real_genes) # the created spatial vectors will be the same as from other input structure  table(rep1_sq10_vectors$gene_mt[,\"DST\"]==rep1_sq10_vectors_lst$gene_mt[,\"DST\"]) ##  ## TRUE  ##  100 # spatial vector for every cluster  head(rep1_sq10_vectors_lst$cluster_mt) ##      c5 c8 c3 c2 c1 c4 c6 c7 ## [1,]  0  0  0  0  4  1  0  1 ## [2,]  0  1  2  0  7  0  0  0 ## [3,]  0  0  1  0 10  0  0  0 ## [4,]  0  0  6  0  5  2  1  1 ## [5,]  0  0  1  0  0  8  7  2 ## [6,]  0  0  4  0  0  3  3  2 # spatial vector for every gene  head(rep1_sq10_vectors_lst$gene_mt) ##      CD68 DST EPCAM ERBB2 FOXA1 KRT7 LUM MYLK PECAM1 PTPRC SERPINA3 AQP1 VWF ## [1,]    9   9    34    76    34   68  13    2      7     3        6    5   2 ## [2,]    4  21   101   170    72  107  34    7     10     2        2   10  10 ## [3,]    6  23   146   249   113  147  25    2      0     0        3    3   5 ## [4,]   14   6    50   153    71  103  81    0      3    16        0    1   1 ## [5,]   28   7    10    45    16   21  20    0      8    52        2    1   1 ## [6,]   21   3     7    46    24    5  39    3     12    21       13    4   0 ##      CCDC80 ITM2C POSTN FGL2 MZB1 IL7R LYZ ## [1,]     13    20    30    4    4    1  12 ## [2,]     21     4    38    2    2    7   6 ## [3,]     12     4    15    0    1    1   3 ## [4,]     23    17    67    5    7   12   9 ## [5,]      6    26    18   41   11   33  57 ## [6,]     36    21    52   27   13   34  30"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-spatialexperiment-object","dir":"Articles","previous_headings":"Example > Spatial vectors > Create spatial vectors for diverse data types","what":"From a SpatialExperiment object","title":"jazzPanda example","text":"transcript coordinates available, can use either transcript coordinates count matrix define spatial vectors genes. defined example_vectors_cm/example_vectors_tr can passed lasso_markers identify marker genes.","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(TENxXeniumData) library(ExperimentHub) library(scran) library(scater) eh <- ExperimentHub() q <- query(eh, \"TENxXenium\") spe_example <- q[[\"EH8547\"]] colData(spe_example)$cell_id <- colnames(spe_example) set.seed(123) # use a subset data subset_cells <- sample(colnames(spe_example), size = 100, replace = FALSE) spe_sub <- spe_example[, colnames(spe_example) %in% subset_cells] # -----------------------------------------------------------------------------  # calculate logcounts and store in object spe_sub <- logNormCounts(spe_sub) rm(spe_example) # compute PCA set.seed(123) spe_sub <- runPCA(spe_sub, subset_row = row.names(spe_sub))  # example Non-spatial clustering (for illustration purpose only) set.seed(123) k <- 10 g <- buildSNNGraph(spe_sub, k = k, use.dimred = \"PCA\") g_walk <- igraph::cluster_walktrap(g) clusters <- paste(\"c\",g_walk$membership,sep=\"\") scran_clusters <- as.data.frame(cbind(cluster = clusters,                                          cell_id = colnames(spe_sub)))  # ----------------------------------------------------------------------------- # combine cluster labels and the coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id clusters_info <- as.data.frame(spatialCoords(spe_sub)) colnames(clusters_info) <- c(\"x\",\"y\") clusters_info$cell_id <- row.names(clusters_info) clusters_info$sample <- spe_sub$sample_id clusters_info <- merge(clusters_info, scran_clusters, by=\"cell_id\") # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  example_vectors_cm <- get_vectors(x= spe_sub,                                 sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(5,5),                                  test_genes = row.names(spe_sub)[1:5],                                 use_cm=TRUE) # spatial vector for every cluster  head(example_vectors_cm$cluster_mt) ##      c1 c2 c3 ## [1,]  2  3  0 ## [2,]  2  2  0 ## [3,]  2  1  0 ## [4,]  2  0  0 ## [5,]  6  6  0 ## [6,]  1  3  0 # spatial vector for every gene  head(example_vectors_cm$gene_mt) ##      2010300C02Rik Acsbg1 Acta2 Acvrl1 Adamts2 ## [1,]            21     20     3      2       0 ## [2,]             9      2     0      0       0 ## [3,]             1      7     0      1       0 ## [4,]            24     17     0      5       0 ## [5,]             9     18     1      4       0 ## [6,]            12     20     0      1       0 # ----------------------------------------------------------------------------- # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr <- get_vectors(x= spe_sub,                                 sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(5,5),                                  test_genes = row.names(spe_sub)[1:5],                                 use_cm=FALSE) # spatial vector for every cluster  # example_vectors_tr$cluster_mt  # spatial vector for every gene  # example_vectors_tr$gene_mt"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-spatialfeatureexperiment-object","dir":"Articles","previous_headings":"Example > Spatial vectors > Create spatial vectors for diverse data types","what":"From a SpatialFeatureExperiment object","title":"jazzPanda example","text":"","code":"sfe_example <-SpatialFeatureExperiment(     list(counts = spe_sub@assays@data$counts),     colData = spe_sub@colData,     spatialCoords = spatialCoords(spe_sub),     spatialCoordsNames = c(\"x_centroid\", \"y_centroid\")) # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id example_vectors_cm <- get_vectors(x= sfe_example,                                 sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(5,5),                                 test_genes = row.names(spe_sub)[1:3],                                 use_cm = TRUE)  # spatial vector for every cluster  head(example_vectors_cm$cluster_mt)  # spatial vector for every gene  head(example_vectors_cm$gene_mt) # ----------------------------------------------------------------------------- # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr <- get_vectors(x= sfe_example,                                 sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(5,5),                                 test_genes = row.names(spe_sub)[1:3],                                 use_cm = FALSE)  # spatial vector for every cluster  # example_vectors_tr$cluster_mt  # spatial vector for every gene  # example_vectors_tr$gene_mt"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-singlecellexperiment-object","dir":"Articles","previous_headings":"Example > Spatial vectors > Create spatial vectors for diverse data types","what":"From a SingleCellExperiment object","title":"jazzPanda example","text":"input SingleCellExperiment object, spatial vectors genes can computed using count matrix cell coordinates defined example_vectors_cm can passed lasso_markers identify marker genes. \\ transcript coordinate information available, can alternatively create SpatialExperiment object compute spatial vectors using transcript coordinates.","code":"sce_example <- SingleCellExperiment(list(sample01 = cm)) # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id example_vectors_cm <- get_vectors(x= sce_example,                                 sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(5,5),                                  test_genes = row.names(spe_sub)[1:3],                                 use_cm=TRUE)  # spatial vector for every cluster  head(example_vectors_cm$cluster_mt)  # spatial vector for every gene  head(example_vectors_cm$gene_mt)  # ----------------------------------------------------------------------------- # If the transcript coordinate information is available # make sure the transcript information contains column names:  # feature_name, x, y spe <- SpatialExperiment(     assays = list(molecules = molecules(sfe_example)),     sample_id =\"sample01\")  # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr <- get_vectors(x= spe, sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(5,5),                                  test_genes = row.names(spe_sub)[1:3]) # spatial vector for every cluster  # example_vectors_tr$cluster_mt  # spatial vector for every gene  # example_vectors_tr$gene_mt"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-seurat-object","dir":"Articles","previous_headings":"Example > Spatial vectors > Create spatial vectors for diverse data types","what":"From a Seurat object","title":"jazzPanda example","text":"Seurat object, spatial vectors genes can computed using count matrix cell coordinates defined example_vectors_cm can passed lasso_markers identify marker genes. \\ transcript coordinate information available, can alternatively create SpatialExperiment object compute spatial vectors using transcript coordinates.","code":"library(Seurat) # suppose cm is the count matrix seu_obj <- Seurat::CreateSeuratObject(counts = cm) sce <- SingleCellExperiment(list(sample01 =seu_obj@assays$RNA$counts )) # we will use the previously defined cluster_info for illustration here # make sure the clusters information contains column names:  # cluster, x, y and sample clusters_info = clusters_info  # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id example_vectors_cm <- get_vectors(x= sce, sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  test_genes = test_genes,                                 use_cm=TRUE) # spatial vector for every cluster  example_vectors_cm$cluster_mt  # spatial vector for every gene  example_vectors_cm$gene_mt  # ----------------------------------------------------------------------------- # If the transcript coordinate information is available # make sure the transcript information contains column names:  # feature_name, x, y spe <- SpatialExperiment(     assays = list(         molecules = molecules(sfe_example)),     sample_id =\"sample01\" )  # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr <- get_vectors(x= spe, sample_names = \"sample01\",                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  test_genes = test_genes) # spatial vector for every cluster  example_vectors_tr$cluster_mt  # spatial vector for every gene  example_vectors_tr$gene_mt"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"linear-relationship-between-markers-and-clusters","dir":"Articles","previous_headings":"Example","what":"Linear relationship between markers and clusters","title":"jazzPanda example","text":"assume relationship marker gene vector cluster spatial vector linear. several genes annotation panel.","code":"genes_lst <- c(\"ERBB2\",\"AQP1\",\"LUM\",\"IL7R\",\"MZB1\")  for (i_cluster in c(\"c1\",\"c8\",\"c3\",\"c6\",\"c7\")){     cluster_vector<-rep1_sq10_vectors$cluster_mt[,i_cluster]          data_vis<-as.data.frame(cbind(\"cluster\", cluster_vector,                             rep1_sq10_vectors$gene_mt[, genes_lst]))          colnames(data_vis)<-c(\"cluster\",\"cluster_vector\",genes_lst)     data_vis<-reshape2::melt(data_vis,variable.name = \"genes\",                             value.name = \"gene_vector\",                             id= c(\"cluster\",\"cluster_vector\" ))     data_vis$cluster_vector<-as.numeric(data_vis$cluster_vector)     data_vis$genes<-factor(data_vis$genes)     data_vis$gene_vector<-as.numeric(data_vis$gene_vector)          plot(ggplot(data = data_vis,              aes(x= cluster_vector, y=gene_vector))+             geom_point(size=0.1)+             facet_wrap(~genes,scales = \"free_y\", ncol=10)+             theme_bw()+             theme(legend.title=element_blank(),                 axis.text.y = element_text(size=6),                 axis.text.x = element_text(size=6,angle=0),                 axis.title.x=element_text(size=10),                 axis.title.y=element_text(size=10),                  panel.spacing = grid::unit(0.5, \"lines\"),                 legend.position=\"none\",                 legend.text=element_blank(),                 strip.text = element_text(size = rel(1)))+                 xlab(paste(i_cluster,\" - cluster vector\", sep=\"\"))+                 ylab(\"gene vector\")) }"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"scenario-1-one-sample","dir":"Articles","previous_headings":"Example","what":"Scenario 1: one sample","title":"jazzPanda example","text":"straightforward approach identifying genes exhibit linear correlation cluster vectors involves computing Pearson correlation gene every cluster. assess statistical significance correlations, compute_permp() function can used perform permutation testing, generating p-value every pair gene cluster cluster vector.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"correlation-based-method-to-detect-marker-genes","dir":"Articles","previous_headings":"Example > Scenario 1: one sample","what":"Correlation-based method to detect marker genes","title":"jazzPanda example","text":"","code":"set.seed(seed_number) perm_p <- compute_permp(x=rep1_sub,                         cluster_info=rep1_clusters,                          perm.size=1000,                         bin_type=\"square\",                         bin_param=c(10,10),                         test_genes= all_real_genes,                         correlation_method = \"pearson\",                          n_cores=1,                          correction_method=\"BH\")  # observed correlation for every pair of gene and cluster vector obs_corr <- get_cor(perm_p) head(obs_corr) ##                c5          c8         c3         c2          c1         c4 ## CD68  -0.26037887  0.06259766  0.2360819 -0.4126090 -0.02885842  0.5951329 ## DST    0.47226365 -0.13560127 -0.4095928  0.4282446  0.51097133 -0.3263375 ## EPCAM -0.11473423 -0.35287011 -0.5724549  0.3454557  0.86438353 -0.3496045 ## ERBB2  0.08159437 -0.34437593 -0.5542681  0.6259111  0.69027586 -0.3613350 ## FOXA1 -0.12850033 -0.33199825 -0.5574530  0.2897598  0.90412737 -0.3504568 ## KRT7  -0.15416641 -0.29950775 -0.5313655  0.1429002  0.93365427 -0.2936415 ##               c6         c7 ## CD68   0.2343318  0.1504930 ## DST   -0.3835009 -0.4094809 ## EPCAM -0.4591613 -0.4444322 ## ERBB2 -0.4587071 -0.4455121 ## FOXA1 -0.4489792 -0.4284400 ## KRT7  -0.4350895 -0.4261375 # permutation adjusted p-value for every pair of gene and cluster vector perm_res <- get_perm_adjp(perm_p) head(perm_res) ##                c5        c8        c3          c2          c1          c4 ## CD68  1.000000000 0.6909757 0.1558442 1.000000000 1.000000000 0.003330003 ## DST   0.006660007 1.0000000 1.0000000 0.009990010 0.003996004 1.000000000 ## EPCAM 1.000000000 1.0000000 1.0000000 0.107892108 0.003996004 1.000000000 ## ERBB2 1.000000000 1.0000000 1.0000000 0.006660007 0.003996004 1.000000000 ## FOXA1 1.000000000 1.0000000 1.0000000 0.402930403 0.003996004 1.000000000 ## KRT7  1.000000000 1.0000000 1.0000000 1.000000000 0.003996004 1.000000000 ##               c6        c7 ## CD68  0.05532929 0.2597403 ## DST   1.00000000 1.0000000 ## EPCAM 1.00000000 1.0000000 ## ERBB2 1.00000000 1.0000000 ## FOXA1 1.00000000 1.0000000 ## KRT7  1.00000000 1.0000000"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-top-marker-genes-detected-by-correlation-approach","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Correlation-based method to detect marker genes","what":"Visualise top marker genes detected by correlation approach","title":"jazzPanda example","text":"Genes significant adjusted p-value considered marker genes corresponding cluster. can rank marker genes observed correlationand plot transcript detection coordinates top three marker genes every cluster.","code":"res_df_1000<-as.data.frame(perm_p$perm.pval.adj) res_df_1000$gene<-row.names(res_df_1000) cluster_names <- unique(as.character(rep1_clusters$cluster)) for (cl in cluster_names){     perm_sig <- res_df_1000[res_df_1000[,cl]<0.05,]     # define a cutoff value based on 75% quantile      obs_cutoff <- quantile(obs_corr[, cl], 0.75)     perm_cl<-intersect(row.names(perm_res[perm_res[,cl]<0.05,]),                         row.names(obs_corr[obs_corr[, cl]>obs_cutoff,]))     inters<-perm_cl     rounded_val<-signif(as.numeric(obs_corr[inters,cl]), digits = 3)     inters_df<- as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value<- as.numeric(inters_df$value)     inters_df<-inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df<-inters_df[1:min(nrow(inters_df),2),]     inters_df$text<- paste(inters_df$gene,inters_df$value,sep=\": \")     curr_genes <- rep1_transcripts$feature_name %in% inters_df$gene     data_vis <- rep1_transcripts[curr_genes, c(\"x\",\"y\",\"feature_name\")]     data_vis$text <- inters_df[match(data_vis$feature_name,inters_df$gene),                                 \"text\"]     data_vis$text <- factor(data_vis$text, levels=inters_df$text)     p1<-ggplot(data = data_vis,                 aes(x = x, y = y))+                 geom_point(size=0.01,color=\"maroon4\")+                 facet_wrap(~text,ncol=10, scales=\"free\")+                 scale_y_reverse()+                 guides(fill = guide_colorbar(height= grid::unit(5, \"cm\")))+                 defined_theme     cl_pt<-ggplot(data = rep1_clusters[rep1_clusters$cluster==cl, ],                     aes(x = x, y = y, color=cluster))+                     geom_point(position=position_jitterdodge(jitter.width=0,                                              jitter.height=0), size=0.2)+                     facet_wrap(~cluster)+                     scale_y_reverse()+                     theme_classic()+                     scale_color_manual(values = \"black\")+                     defined_theme     lyt <- cl_pt | p1     layout_design <- lyt + patchwork::plot_layout(widths = c(1,3))      print(layout_design) }"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-cluster-vector-and-the-top-marker-genes-at-spatial-vector-level","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Correlation-based method to detect marker genes","what":"Visualise cluster vector and the top marker genes at spatial vector level","title":"jazzPanda example","text":"check linear relationship cluster vector marker gene vectors, can plot cluster vector x-axis, marker gene vector y-axis. figure shows relationship cluster vector top marker gene vectors detected correlation approach. method identify linearly correlated genes cluster construct linear model gene. can use lasso_markers function get relevant cluster label every gene.","code":"cluster_names <- paste(\"c\", 1:8, sep=\"\") plot_lst<-list() for (cl in cluster_names){     perm_sig<- res_df_1000[res_df_1000[,cl]<0.05,]     curr_cell_type <- all_celltypes[all_celltypes$cluster==cl,\"anno\"]     obs_cutoff <- quantile(obs_corr[, cl], 0.75)     perm_cl<-intersect(row.names(perm_res[perm_res[,cl]<0.05,]),                         row.names(obs_corr[obs_corr[, cl]>obs_cutoff,]))     inters<-perm_cl     rounded_val<-signif(as.numeric(obs_corr[inters,cl]), digits = 3)     inters_df <- as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value<- as.numeric(inters_df$value)     inters_df<-inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text<- paste(inters_df$gene,inters_df$value,sep=\": \")     mk_gene<- inters_df[1:min(2, nrow(inters_df)),\"gene\"]     if (length(mk_gene > 0)){         dff <- as.data.frame(cbind(rep1_sq10_vectors$cluster_mt[,cl],                                     rep1_sq10_vectors$gene_mt[,mk_gene]))         colnames(dff) <- c(\"cluster\", mk_gene)                  dff$vector_id <- c(1:(grid_length * grid_length))         long_df <- dff %>%          pivot_longer(cols = -c(cluster, vector_id), names_to = \"gene\",                                  values_to = \"vector_count\")         long_df$gene <- factor(long_df$gene, levels=mk_gene)                  p<-ggplot(long_df, aes(x = cluster, y = vector_count )) +             geom_point( size=0.01) +             facet_wrap(~gene, scales = \"free_y\", nrow=1) +             labs(x = paste(\"cluster vector \", curr_cell_type, sep=\"\"),                      y = \"marker gene vectors\") +             theme_minimal()+             guides(color=guide_legend(nrow = 1,                         override.aes=list(alpha=1, size=2)))+             theme(panel.grid = element_blank(),legend.position = \"none\",                     strip.text = element_text(size = rel(1)),                     axis.line=element_blank(),                     legend.title = element_blank(),                     legend.key.size = grid::unit(0.5, \"cm\"),                     legend.text = element_text(size=10),                     axis.text=element_blank(),                     axis.ticks=element_blank(),                     axis.title=element_text(size = 10),                     panel.border =element_rect(colour = \"black\",                                                  fill=NA, linewidth=0.5)             )         plot_lst[[cl]] = p     } } combined_plot <- ggarrange(plotlist = plot_lst,                              ncol = 2, nrow = 4,                             common.legend = FALSE, legend = \"none\")  combined_plot"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"linear-modeling-approach-to-detect-marker-genes","dir":"Articles","previous_headings":"Example > Scenario 1: one sample","what":"Linear modeling approach to detect marker genes","title":"jazzPanda example","text":"can create spatial vectors negative control genes include background noise “clusters”. calling lasso_markers() detecting marker genes, please make sure gene_mt cluster_mt calculated get_vector() call share exact auto-detected bounding box. Mixing outputs separate calls can misalign spatial bins lead incorrect results.","code":"probe_nm <- unique(rep1_nc_data[rep1_nc_data$category==\"probe\",\"feature_name\"]) codeword_nm <- unique(rep1_nc_data[rep1_nc_data$category==\"codeword\",                                     \"feature_name\"]) rep1_nc_vectors <- create_genesets(x=rep1_neg,sample_names=\"rep1\",                                     name_lst=list(probe=probe_nm,                                                  codeword=codeword_nm),                                      bin_type=\"square\",                                     bin_param=c(10, 10),                                      cluster_info = NULL)  set.seed(seed_number)  rep1_lasso_with_nc <- lasso_markers(gene_mt=rep1_sq10_vectors$gene_mt,                                     cluster_mt = rep1_sq10_vectors$cluster_mt,                                     sample_names=c(\"rep1\"),                                     keep_positive=TRUE,                                      background=rep1_nc_vectors)  rep1_top_df_nc <- get_top_mg(rep1_lasso_with_nc, coef_cutoff=0.2) # the top result table  head(rep1_top_df_nc) ##        gene top_cluster  glm_coef   pearson max_gg_corr max_gc_corr ## CD68   CD68          c4  4.449040 0.5951329   0.5143408   0.5951329 ## DST     DST          c1  2.055449 0.5109713   0.6765032   0.5109713 ## EPCAM EPCAM          c1 10.669336 0.8643835   0.9547929   0.8643835 ## ERBB2 ERBB2          c1 14.743715 0.6902759   0.8864028   0.6902759 ## FOXA1 FOXA1          c1 10.225876 0.9041274   0.9547929   0.9041274 ## KRT7   KRT7          c1 14.158329 0.9336543   0.9541634   0.9336543 # the full result table  rep1_full_df <- get_full_mg(rep1_lasso_with_nc) head(rep1_full_df) ##      gene cluster glm_coef      p_value   pearson max_gg_corr max_gc_corr ## 32   AQP1      c8 7.016576 1.783816e-25 0.8270796   0.8442294   0.8270796 ## 33   AQP1      c6 1.720408 7.631997e-05 0.3209543   0.8442294   0.8270796 ## 34   AQP1      c3 1.039118 2.122195e-03 0.2099349   0.8442294   0.8270796 ## 38 CCDC80      c3 3.867855 1.849497e-20 0.7163637   0.8086714   0.7163637 ## 39 CCDC80      c7 1.533487 3.734641e-02 0.2349379   0.8086714   0.7163637 ## 1    CD68      c4 4.449040 2.744019e-11 0.5951329   0.5143408   0.5951329"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-top-marker-genes-detected-by-linear-modelling-approach","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Linear modeling approach to detect marker genes","what":"Visualise top marker genes detected by linear modelling approach","title":"jazzPanda example","text":"can rank marker genes linear model coefficient cluster ans plot transcript detection coordinates top three marker genes every cluster.","code":"cluster_names <- paste(\"c\", 1:8, sep=\"\") for (cl in setdiff(cluster_names,\"NoSig\")){     inters<-rep1_top_df_nc[rep1_top_df_nc$top_cluster==cl,\"gene\"]     rounded_val<-signif(as.numeric(rep1_top_df_nc[inters,\"glm_coef\"]),                                     digits = 3)     inters_df <- as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value <- as.numeric(inters_df$value)     inters_df<-inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text<- paste(inters_df$gene,inters_df$value,sep=\": \")          if (length(inters > 0)){         inters_df<-inters_df[1:min(2, nrow(inters_df)),]         inters <-inters_df$gene         iters_rep1<-rep1_transcripts$feature_name %in% inters         vis_r1<-rep1_transcripts[iters_rep1,                                 c(\"x\",\"y\",\"feature_name\")]         vis_r1$value<-inters_df[match(vis_r1$feature_name,inters_df$gene),                                 \"value\"]         #vis_r1=vis_r1[order(vis_r1$value,decreasing = TRUE),]         vis_r1$text_label<- paste(vis_r1$feature_name,                                     vis_r1$value,sep=\": \")         vis_r1$text_label<-factor(vis_r1$text_label, levels = inters_df$text)         vis_r1$sample<-\"rep1\"         p1<- ggplot(data = vis_r1,                     aes(x = x, y = y))+                      geom_point(size=0.01,color=\"maroon4\")+                     facet_wrap(~text_label,ncol=10, scales=\"free\")+                     scale_y_reverse()+                     guides(fill = guide_colorbar(height= grid::unit(5, \"cm\")))+                     defined_theme         cl_pt<-ggplot(data = rep1_clusters[rep1_clusters$cluster==cl, ],                     aes(x = x, y = y, color=cluster))+                     geom_point(position=position_jitterdodge(jitter.width=0,                                              jitter.height=0), size=0.2)+                     facet_wrap(~cluster)+                     scale_y_reverse()+                     theme_classic()+                     scale_color_manual(values = \"black\")+                     defined_theme         lyt <- cl_pt | p1         layout_design <- lyt + patchwork::plot_layout(widths = c(1,3))          print(layout_design) }}"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-cluster-vector-and-the-top-marker-genes-at-spatial-vector-level-1","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Linear modeling approach to detect marker genes","what":"Visualise cluster vector and the top marker genes at spatial vector level","title":"jazzPanda example","text":"can plot cluster vector x-axis, marker gene vectors (detected linear modelling approach) y-axis validate linear relationship assumption cluster vector marker gene vectors.","code":"cluster_names <- paste(\"c\", 1:8, sep=\"\") plot_lst=list() for (cl in cluster_names){     curr_cell_type<-all_celltypes[all_celltypes$cluster==cl,\"anno\"]     inters<-rep1_top_df_nc[rep1_top_df_nc$top_cluster==cl,\"gene\"]     if (length(inters > 0)){         rounded_val<-signif(as.numeric(rep1_top_df_nc[inters,\"glm_coef\"]),                                 digits = 3)         inters_df<-as.data.frame(cbind(gene=inters, value=rounded_val))         inters_df$value<-as.numeric(inters_df$value)         inters_df<-inters_df[order(inters_df$value, decreasing = TRUE),]         inters_df$text<-paste(inters_df$gene,inters_df$value,sep=\": \")              inters_df<-inters_df[1:min(2, nrow(inters_df)),]         mk_gene<-inters_df$gene          dff<- as.data.frame(cbind(rep1_sq10_vectors$cluster_mt[,cl],                                 rep1_sq10_vectors$gene_mt[,mk_gene]))         colnames(dff)<-c(\"cluster\", mk_gene)         dff$vector_id<-c(1:(grid_length * grid_length))         long_df <- dff %>%          pivot_longer(cols = -c(cluster, vector_id), names_to = \"gene\",                          values_to = \"vector_count\")         long_df$gene<-factor(long_df$gene, levels=mk_gene)         p<-ggplot(long_df, aes(x = cluster, y = vector_count )) +             geom_point( size=0.01) +             facet_wrap(~gene, scales = \"free_y\", nrow=1) +             labs(x = paste(\"cluster vector \", curr_cell_type, sep=\"\"),                      y = \"marker gene vectors\") +             theme_minimal()+             guides(color=guide_legend(nrow = 1,                         override.aes=list(alpha=1, size=2)))+             theme(panel.grid = element_blank(),legend.position = \"none\",                     strip.text = element_text(size = rel(1)),                     axis.line=element_blank(),                     legend.title = element_blank(),                     legend.key.size = grid::unit(0.5, \"cm\"),                     legend.text = element_text(size=10),                     axis.text=element_blank(),                     axis.ticks=element_blank(),                     axis.title=element_text(size = 10),                     panel.border =element_rect(colour = \"black\",                                                  fill=NA, linewidth=0.5)         )         plot_lst[[cl]] = p     } } combined_plot <- ggarrange(plotlist = plot_lst,                              ncol = 2, nrow = 4,                             common.legend = FALSE, legend = \"none\")  combined_plot"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"scenario-2-multiple-samples","dir":"Articles","previous_headings":"Example","what":"Scenario 2: multiple samples","title":"jazzPanda example","text":"Load replicate 2 sample 1.","code":"data(rep2_sub, rep2_clusters, rep2_neg) rep2_clusters$cluster<-factor(rep2_clusters$cluster,                             levels=paste(\"c\",1:8, sep=\"\")) rep1_clusters$cells<-paste(row.names(rep1_clusters),\"_1\",sep=\"\") rep2_clusters$cells<-paste(row.names(rep2_clusters),\"_2\",sep=\"\") rep_clusters<-rbind(rep1_clusters,rep2_clusters) rep_clusters$cluster<-factor(rep_clusters$cluster,                             levels=paste(\"c\",1:8, sep=\"\")) table(rep_clusters$sample, rep_clusters$cluster) ##        ##         c1  c2  c3  c4  c5  c6  c7  c8 ##   rep1 745 205 221 127  87 176  45  99 ##   rep2  27 476 313 190 360 256  99  94 # record the transcript coordinates for rep2 rep2_transcripts <-BumpyMatrix::unsplitAsDataFrame(molecules(rep2_sub)) rep2_transcripts <- as.data.frame(rep2_transcripts) colnames(rep2_transcripts) <- c(\"feature_name\",\"cell_id\",\"x\",\"y\") # record the negative control transcript coordinates for rep2 rep2_nc_data <-BumpyMatrix::unsplitAsDataFrame(molecules(rep2_neg)) rep2_nc_data <- as.data.frame(rep2_nc_data) colnames(rep2_nc_data) <- c(\"feature_name\",\"cell_id\",\"x\",\"y\",\"category\")"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-the-clusters","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples","what":"Visualise the clusters","title":"jazzPanda example","text":"can plot coordinates cells every cluster every replicate  multiple replicates dataset, can find marker genes providing additional sample information input function lasso_markers.","code":"ggplot(data = rep_clusters,         aes(x = x, y = y, color=cluster))+         geom_point(position=position_jitterdodge(jitter.width=0,                                                  jitter.height=0),size=0.1)+         facet_grid(sample~cluster)+         scale_y_reverse()+         theme_classic()+         scale_color_manual(values = c(\"#FC8D62\",\"#66C2A5\" ,\"#8DA0CB\",\"#E78AC3\",                                 \"#A6D854\",\"skyblue\",\"purple3\",\"#E5C498\"))+         guides(color=guide_legend(title=\"cluster\", nrow = 1,         override.aes=list(alpha=1, size=7)))+         theme(             axis.line=element_blank(),             axis.text.x=element_blank(),             axis.text.y=element_blank(),             axis.ticks=element_blank(),             axis.title.x=element_blank(),             axis.title.y=element_blank(),             panel.background=element_blank(),             panel.border=element_blank(),             panel.grid.major=element_blank(),             panel.grid.minor=element_blank(),             plot.background=element_blank(),             legend.text = element_text(size=10),             legend.position=\"none\",             legend.title = element_text(size=10),             strip.text = element_text(size = rel(1)))+         xlab(\"\")+         ylab(\"\")"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"linear-modeling-approach-to-detect-marker-genes-1","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples","what":"Linear modeling approach to detect marker genes","title":"jazzPanda example","text":"calling lasso_markers() detecting marker genes, please make sure gene_mt cluster_mt calculated get_vector() call share exact auto-detected bounding box. Mixing outputs separate calls can misalign spatial bins lead incorrect results.","code":"grid_length<-10 twosample_spe<-cbind(rep1_sub, rep2_sub) # get spatial vectors two_rep_vectors<- get_vectors(x= twosample_spe,                                 sample_names=c(\"rep1\",\"rep2\"),                                 cluster_info = rep_clusters, bin_type=\"square\",                                 bin_param=c(grid_length, grid_length),                                 test_genes = all_real_genes)  twosample_neg_spe<-cbind(rep1_neg, rep2_neg)  probe_nm<-unique(c(rep1_nc_data[rep1_nc_data$category==\"probe\",                                 \"feature_name\"],                 rep2_nc_data[rep2_nc_data$category==\"probe\",\"feature_name\"])) codeword_nm<-unique(c(rep1_nc_data[rep1_nc_data$category==\"codeword\",                                 \"feature_name\"],             rep2_nc_data[rep2_nc_data$category==\"codeword\",\"feature_name\"]))  two_rep_nc_vectors<-create_genesets(x=twosample_neg_spe,                                     sample_names=c(\"rep1\",\"rep2\"),                                     name_lst=list(probe=probe_nm,                                                  codeword=codeword_nm),                                     bin_type=\"square\",                                     bin_param=c(10,10),                                      cluster_info = NULL) set.seed(seed_number) two_rep_lasso_with_nc<-lasso_markers(gene_mt=two_rep_vectors$gene_mt,                                     cluster_mt = two_rep_vectors$cluster_mt,                                     sample_names=c(\"rep1\",\"rep2\"),                                     keep_positive=TRUE,                                      background=two_rep_nc_vectors,n_fold = 5)  tworep_res<-get_top_mg(two_rep_lasso_with_nc, coef_cutoff=0.2)  tworep_res$celltype<-rep_clusters[match(tworep_res$top_cluster,                                             rep_clusters$cluster),\"anno\"] table(tworep_res$top_cluster) ##  ## c1 c2 c3 c4 c5 c6 c7 c8  ##  3  2  3  3  2  2  2  3 head(tworep_res) ##        gene top_cluster  glm_coef   pearson max_gg_corr max_gc_corr ## CD68   CD68          c4  2.867318 0.6989050   0.6511176   0.6989050 ## DST     DST          c5  7.489462 0.8670218   0.8197079   0.8670218 ## EPCAM EPCAM          c1  9.178748 0.6198084   0.9389694   0.6198084 ## ERBB2 ERBB2          c2 21.395744 0.7780134   0.9051871   0.7780134 ## FOXA1 FOXA1          c1  8.642193 0.5549087   0.9389694   0.6054385 ## KRT7   KRT7          c1 11.974428 0.6505399   0.9154447   0.6505399 ##            celltype ## CD68    Macrophages ## DST   Myoepithelial ## EPCAM         Tumor ## ERBB2          DCIS ## FOXA1         Tumor ## KRT7          Tumor"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-the-top-marker-genes-for-each-cluster","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples > Linear modeling approach to detect marker genes","what":"Visualise the top marker genes for each cluster","title":"jazzPanda example","text":"","code":"for (cl in all_celltypes$anno){     inters<-tworep_res[tworep_res$celltype==cl,\"gene\"]     rounded_val<-signif(as.numeric(tworep_res[inters,\"glm_coef\"]),                         digits = 3)     inters_df<-as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value<-as.numeric(inters_df$value)     inters_df<-inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text<-paste(inters_df$gene,inters_df$value,sep=\": \")     if (length(inters > 0)){         inters_df<-inters_df[1:min(2, nrow(inters_df)),]         inters<-inters_df$gene         iters_rep1<-rep1_transcripts$feature_name %in% inters         vis_r1<-rep1_transcripts[iters_rep1,                                 c(\"x\",\"y\",\"feature_name\")]         vis_r1$value<-inters_df[match(vis_r1$feature_name,inters_df$gene),                                 \"value\"]         vis_r1<-vis_r1[order(vis_r1$value,decreasing = TRUE),]         vis_r1$text_label<- paste(vis_r1$feature_name,                                     vis_r1$value,sep=\": \")         vis_r1$text_label<-factor(vis_r1$text_label)         vis_r1$sample<-\"rep1\"         iters_rep2<- rep2_transcripts$feature_name %in% inters         vis_r2<-rep2_transcripts[iters_rep2,                                 c(\"x\",\"y\",\"feature_name\")]         vis_r2$value<-inters_df[match(vis_r2$feature_name,inters_df$gene),                                 \"value\"]         vis_r2<-vis_r2[order(vis_r2$value, decreasing = TRUE),]         vis_r2$text_label<-paste(vis_r2$feature_name,                                 vis_r2$value,sep=\": \")         vis_r2$text_label<-factor(vis_r2$text_label)         vis_r2$sample<-\"rep2\"         p1<- ggplot(data = vis_r1,                     aes(x = x, y = y))+                      geom_point(size=0.01,color=\"maroon4\")+                     facet_grid(sample~text_label, scales=\"free\")+                     scale_y_reverse()+                     guides(fill = guide_colorbar(height= grid::unit(5, \"cm\")))+                     defined_theme         p2<- ggplot(data = vis_r2,                     aes(x = x, y = y))+                      geom_point(size=0.01,color=\"maroon4\")+                     facet_grid(sample~text_label,scales=\"free\")+                     scale_y_reverse()+                     guides(fill = guide_colorbar(height= grid::unit(5, \"cm\")))+                     defined_theme                  cl_pt<-ggplot(data = rep_clusters[rep_clusters$anno==cl, ],                     aes(x = x, y = y, color=cluster))+                     geom_point(position=position_jitterdodge(jitter.width=0,                                              jitter.height=0), size=0.2)+                     facet_grid(sample~cluster)+                     scale_y_reverse()+                     theme_classic()+                     scale_color_manual(values = \"black\")+                     defined_theme         lyt <- cl_pt | (p1 / p2)          # if (cl %in% c(\"c2\",\"c5\",\"c6\",\"c7\")){         #     lyt <- cl_pt | ((p1 / p2) | patchwork::plot_spacer())            # }         layout_design <- lyt + patchwork::plot_layout(widths = c(1,2))           print(layout_design) }}"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-cluster-vector-and-the-top-marker-genes-at-spatial-vector-level-2","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples > Linear modeling approach to detect marker genes","what":"Visualise cluster vector and the top marker genes at spatial vector level","title":"jazzPanda example","text":"figure shows relationship cluster vector top marker gene vectors detected linear modelling approach accounting multiple samples background noise","code":"cluster_names<-paste(\"c\", 1:8, sep=\"\") plot_lst<-list() for (cl in cluster_names){     inters<-tworep_res[tworep_res$top_cluster==cl,\"gene\"]     curr_cell_type<- all_celltypes[all_celltypes$cluster==cl,\"anno\"]     rounded_val<-signif(as.numeric(tworep_res[inters,\"glm_coef\"]),                             digits = 3)     inters_df<-as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value<-as.numeric(inters_df$value)     inters_df<-inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text<-paste(inters_df$gene,inters_df$value,sep=\": \")              mk_gene<-inters_df[1:min(2, nrow(inters_df)),\"gene\"]     if (length(inters > 0)){         dff<-as.data.frame(cbind(two_rep_vectors$cluster_mt[,cl],                                     two_rep_vectors$gene_mt[,mk_gene]))         colnames(dff) <- c(\"cluster\", mk_gene)         total_tiles <- grid_length * grid_length         dff$vector_id <- c(1:total_tiles)         dff$sample<- \"Replicate1\"         dff[(total_tiles+1):(total_tiles*2),\"sample\"] <- \"Replicate2\"         dff$vector_id <- c(1:total_tiles, 1:total_tiles)         long_df <- dff %>%          pivot_longer(cols = -c(cluster, sample, vector_id), names_to = \"gene\",                          values_to = \"vector_count\")         long_df$gene <- factor(long_df$gene, levels=mk_gene)         p<-ggplot(long_df,                          aes(x = cluster, y = vector_count, color =sample)) +             geom_point( size=0.01) +             facet_wrap(~gene, scales = \"free_y\", nrow=1) +             labs(x = paste(\"cluster vector \", curr_cell_type, sep=\"\"),                      y = \"marker gene vectors\") +             theme_minimal()+             guides(color=guide_legend(nrow = 1,                         override.aes=list(alpha=1, size=2)))+             theme(panel.grid = element_blank(),legend.position = \"bottom\",                     strip.text = element_text(size = rel(1)),                     axis.line=element_blank(),                     legend.title = element_blank(),                     legend.key.size = grid::unit(0.5, \"cm\"),                     legend.text = element_text(size=10),                     axis.text=element_blank(),                     axis.ticks=element_blank(),                     axis.title=element_text(size = 10),                     panel.border =element_rect(colour = \"black\",                                                  fill=NA, linewidth=0.5)             )         plot_lst[[cl]] <- p     } } combined_plot <- ggarrange(plotlist = plot_lst,                              ncol = 2, nrow = 4,                             common.legend = TRUE, legend = \"top\")  combined_plot"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"session-info","dir":"Articles","previous_headings":"","what":"Session Info","title":"jazzPanda example","text":"","code":"sessionInfo() ## R version 4.5.1 (2025-06-13) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 24.04.2 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.26.so;  LAPACK version 3.12.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] grid      stats4    stats     graphics  grDevices utils     datasets  ## [8] methods   base      ##  ## other attached packages: ##  [1] scater_1.36.0                   scran_1.36.0                    ##  [3] scuttle_1.18.0                  TENxXeniumData_1.4.0            ##  [5] ExperimentHub_2.16.1            AnnotationHub_3.16.1            ##  [7] BiocFileCache_2.16.1            dbplyr_2.5.0                    ##  [9] SpatialFeatureExperiment_1.10.1 ggpubr_0.6.1                    ## [11] tidyr_1.3.1                     spatstat_3.4-0                  ## [13] spatstat.linnet_3.3-1           spatstat.model_3.4-0            ## [15] rpart_4.1.24                    spatstat.explore_3.5-2          ## [17] nlme_3.1-168                    spatstat.random_3.4-1           ## [19] spatstat.geom_3.5-0             spatstat.univar_3.1-4           ## [21] spatstat.data_3.1-8             gridExtra_2.3                   ## [23] ggrepel_0.9.6                   ggraph_2.2.1                    ## [25] igraph_2.1.4                    corrplot_0.95                   ## [27] caret_7.0-1                     lattice_0.22-7                  ## [29] glmnet_4.1-10                   Matrix_1.7-3                    ## [31] dplyr_1.1.4                     data.table_1.17.8               ## [33] ggplot2_3.5.2                   SpatialExperiment_1.18.1        ## [35] SingleCellExperiment_1.30.1     SummarizedExperiment_1.38.1     ## [37] Biobase_2.68.0                  GenomicRanges_1.60.0            ## [39] GenomeInfoDb_1.44.1             IRanges_2.42.0                  ## [41] S4Vectors_0.46.0                BiocGenerics_0.54.0             ## [43] generics_0.1.4                  MatrixGenerics_1.20.0           ## [45] matrixStats_1.5.0               jazzPanda_1.1.1                 ##  ## loaded via a namespace (and not attached): ##   [1] fs_1.6.6                  spatialreg_1.3-6          ##   [3] spatstat.sparse_3.1-0     bitops_1.0-9              ##   [5] sf_1.0-21                 EBImage_4.50.0            ##   [7] lubridate_1.9.4           doParallel_1.0.17         ##   [9] httr_1.4.7                RColorBrewer_1.1-3        ##  [11] tools_4.5.1               backports_1.5.0           ##  [13] R6_2.6.1                  HDF5Array_1.36.0          ##  [15] mgcv_1.9-3                rhdf5filters_1.20.0       ##  [17] withr_3.0.2               sp_2.2-0                  ##  [19] cli_3.6.5                 textshaping_1.0.1         ##  [21] sandwich_3.1-1            labeling_0.4.3            ##  [23] sass_0.4.10               mvtnorm_1.3-3             ##  [25] proxy_0.4-27              pkgdown_2.1.3             ##  [27] systemfonts_1.2.3         R.utils_2.13.0            ##  [29] parallelly_1.45.1         limma_3.64.3              ##  [31] RSQLite_2.4.2             shape_1.4.6.1             ##  [33] car_3.1-3                 spdep_1.3-13              ##  [35] ggbeeswarm_0.7.2          abind_1.4-8               ##  [37] R.methodsS3_1.8.2         terra_1.8-60              ##  [39] lifecycle_1.0.4           multcomp_1.4-28           ##  [41] yaml_2.3.10               edgeR_4.6.3               ##  [43] carData_3.0-5             rhdf5_2.52.1              ##  [45] recipes_1.3.1             SparseArray_1.8.1         ##  [47] blob_1.2.4                dqrng_0.4.1               ##  [49] crayon_1.5.3              cowplot_1.2.0             ##  [51] beachmat_2.24.0           KEGGREST_1.48.1           ##  [53] magick_2.8.7              metapod_1.16.0            ##  [55] zeallot_0.2.0             pillar_1.11.0             ##  [57] knitr_1.50                rjson_0.2.23              ##  [59] boot_1.3-31               future.apply_1.20.0       ##  [61] codetools_0.2-20          wk_0.9.4                  ##  [63] glue_1.8.0                vctrs_0.6.5               ##  [65] png_0.1-8                 gtable_0.3.6              ##  [67] cachem_1.1.0              gower_1.0.2               ##  [69] xfun_0.53                 mime_0.13                 ##  [71] S4Arrays_1.8.1            prodlim_2025.04.28        ##  [73] DropletUtils_1.28.1       tidygraph_1.3.1           ##  [75] coda_0.19-4.1             survival_3.8-3            ##  [77] timeDate_4041.110         sfheaders_0.4.4           ##  [79] iterators_1.0.14          hardhat_1.4.1             ##  [81] units_0.8-7               lava_1.8.1                ##  [83] bluster_1.18.0            statmod_1.5.0             ##  [85] TH.data_1.1-3             ipred_0.9-15              ##  [87] bit64_4.6.0-1             filelock_1.0.3            ##  [89] BumpyMatrix_1.16.0        bslib_0.9.0               ##  [91] irlba_2.3.5.1             vipor_0.4.7               ##  [93] KernSmooth_2.23-26        spData_2.3.4              ##  [95] DBI_1.2.3                 nnet_7.3-20               ##  [97] tidyselect_1.2.1          curl_7.0.0                ##  [99] bit_4.6.0                 compiler_4.5.1            ## [101] BiocNeighbors_2.2.0       h5mread_1.0.1             ## [103] desc_1.4.3                DelayedArray_0.34.1       ## [105] scales_1.4.0              classInt_0.4-11           ## [107] rappdirs_0.3.3            tiff_0.1-12               ## [109] stringr_1.5.1             digest_0.6.37             ## [111] goftest_1.2-3             fftwtools_0.9-11          ## [113] spatstat.utils_3.1-5      rmarkdown_2.29            ## [115] XVector_0.48.0            htmltools_0.5.8.1         ## [117] pkgconfig_2.0.3           jpeg_0.1-11               ## [119] sparseMatrixStats_1.20.0  fastmap_1.2.0             ## [121] rlang_1.1.6               htmlwidgets_1.6.4         ## [123] UCSC.utils_1.4.0          DelayedMatrixStats_1.30.0 ## [125] farver_2.1.2              jquerylib_0.1.4           ## [127] zoo_1.8-14                jsonlite_2.0.0            ## [129] BiocParallel_1.42.1       ModelMetrics_1.2.2.2      ## [131] R.oo_1.27.1               BiocSingular_1.24.0       ## [133] RCurl_1.98-1.17           magrittr_2.0.3            ## [135] Formula_1.2-5             GenomeInfoDbData_1.2.14   ## [137] s2_1.1.9                  patchwork_1.3.1           ## [139] Rhdf5lib_1.30.0           Rcpp_1.1.0                ## [141] viridis_0.6.5             stringi_1.8.7             ## [143] pROC_1.19.0.1             MASS_7.3-65               ## [145] plyr_1.8.9                parallel_4.5.1            ## [147] listenv_0.9.1             deldir_2.0-4              ## [149] Biostrings_2.76.0         graphlayouts_1.2.2        ## [151] splines_4.5.1             tensor_1.5.1              ## [153] locfit_1.5-9.12           ggsignif_0.6.4            ## [155] ScaledMatrix_1.16.0       reshape2_1.4.4            ## [157] LearnBayes_2.15.1         BiocVersion_3.21.1        ## [159] evaluate_1.0.4            BiocManager_1.30.26       ## [161] foreach_1.5.2             tweenr_2.0.3              ## [163] purrr_1.1.0               polyclip_1.10-7           ## [165] future_1.67.0             ggforce_0.5.0             ## [167] rsvd_1.0.5                broom_1.0.9               ## [169] e1071_1.7-16              rstatix_0.7.2             ## [171] viridisLite_0.4.2         class_7.3-23              ## [173] ragg_1.4.0                tibble_3.3.0              ## [175] beeswarm_0.4.0            AnnotationDbi_1.70.0      ## [177] memoise_2.0.1             cluster_2.1.8.1           ## [179] timechange_0.3.0          globals_0.18.0"},{"path":"https://phipsonlab.github.io/jazzPanda/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Melody Jin. Author, maintainer.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jin M (2025). jazzPanda: Finding spatially relevant marker genes image based spatial transcriptomics data. R package version 1.1.1, https://github.com/phipsonlab/jazzPanda.","code":"@Manual{,   title = {jazzPanda: Finding spatially relevant marker genes in image based spatial transcriptomics data},   author = {Melody Jin},   year = {2025},   note = {R package version 1.1.1},   url = {https://github.com/phipsonlab/jazzPanda}, }"},{"path":"https://phipsonlab.github.io/jazzPanda/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Finding spatially relevant marker genes in image based spatial transcriptomics data","text":"jazzPanda package contains functions find marker genes based spatial coordinates imaging-based spatial transcriptomics technologies including 10x Xenium, NanoString CosMx Vizgen MERSCOPE.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Finding spatially relevant marker genes in image based spatial transcriptomics data","text":"install jazzPanda Bioconductor, use following commands: install jazzPanda github, use following commands: order view vignette jazzPanda use following command:","code":"if (!requireNamespace(\"BiocManager\", quietly = TRUE))     install.packages(\"BiocManager\")  BiocManager::install(\"jazzPanda\") library(devtools) devtools::install_github(\"phipsonlab/jazzPanda\") browseVignettes(\"jazzPanda\")"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a p-value for correlation with permutation. — compute_permp","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"function run permutation framework compute p-value correlation vectorised genes clusters cluster one sample.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"","code":"compute_permp(   x,   cluster_info,   perm.size,   bin_type,   bin_param,   test_genes,   correlation_method = \"pearson\",   n_cores = 1,   correction_method = \"BH\",   use_cm = FALSE )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"x named list (transcript detection coordinates) named SingleCellExperiment named SpatialExperiment named SpatialFeatureExperiment object. named list provided, list element dataframe containing transcript detection coordinates column names must include \"feature_name\" (gene name), \"x\" (x coordinate), \"y\" (y coordinate). list name must match samples cluster_info. cluster_info dataframe/matrix containing centroid coordinates cluster label cell.column names include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label). perm.size positive number specifying permutation times bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . test_genes vector strings giving name genes want test correlation . gene_mt. correlation_method parameter pass cor indicating correlation coefficient computed. One \"pearson\" (default), \"kendall\", \"spearman\": can abbreviated. n_cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing). correction_method character string pass p.adjust specifying correction method multiple testing . use_cm boolean value specifies whether create spatial vectors genes using count matrix cell coordinates instead transcript coordinates types information available. default setting FALSE.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"object class 'cor_mg_result'. access specific components returned object: Use get_cor retrieve matrix observed correlation coefficients. Use get_perm_p access matrix raw permutation p-values. Use get_perm_adjp obtain matrix adjusted permutation p-values.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"get permutation p-value correlation gene cluster, function permute cluster label cell randomly, calculate correlation genes permuted clusters. process repeated perm.size times, permutation p-value calculated probability permuted correlations larger observation correlation.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"","code":"library(SpatialExperiment) #> Loading required package: SingleCellExperiment #> Loading required package: SummarizedExperiment #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: ‘MatrixGenerics’ #> The following objects are masked from ‘package:matrixStats’: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: stats4 #> Loading required package: BiocGenerics #> Loading required package: generics #>  #> Attaching package: ‘generics’ #> The following objects are masked from ‘package:base’: #>  #>     as.difftime, as.factor, as.ordered, intersect, is.element, setdiff, #>     setequal, union #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, aperm, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, is.unsorted, lapply, #>     mapply, match, mget, order, paste, pmax, pmax.int, pmin, pmin.int, #>     rank, rbind, rownames, sapply, saveRDS, table, tapply, unique, #>     unsplit, which.max, which.min #> Loading required package: S4Vectors #>  #> Attaching package: ‘S4Vectors’ #> The following object is masked from ‘package:utils’: #>  #>     findMatches #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: ‘Biobase’ #> The following object is masked from ‘package:MatrixGenerics’: #>  #>     rowMedians #> The following objects are masked from ‘package:matrixStats’: #>  #>     anyMissing, rowMedians library(BumpyMatrix) set.seed(100) # simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=10, mean=20, sd=5),                     y = rnorm(n=10, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=10, mean=100, sd=5),                     y = rnorm(n=10, mean=100, sd=5), cluster=\"B\") clusters <- rbind(df_clA, df_clB) clusters$sample=\"sample1\" # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A1\"),                     cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A2\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B1\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell =  rep(paste(\"cell\",1:20, sep=\"\"), times=2) mol <- BumpyMatrix::splitAsBumpyMatrix(      trans_info[, c(\"x\", \"y\")],       row = trans_info$feature_name, col = trans_info$cell ) spe_sample1 <- SpatialExperiment(         assays = list(molecules = mol),sample_id =\"sample1\" ) set.seed(100) corr_res <- compute_permp(x=spe_sample1,              cluster_info=clusters,              perm.size=10,              bin_type=\"square\",              bin_param=c(2,2),              test_genes=unique(trans_info$feature_name),              correlation_method = \"pearson\",              n_cores=1,              correction_method=\"BH\") #> Correlation Method = pearson #> Running 10 permutation in sequential               # raw permutation p-value perm_p <- get_perm_p(corr_res) # adjusted permutation p-value adjusted_perm_p <- get_perm_adjp(corr_res) # observed correlation  obs_corr <- get_cor(corr_res)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the coordinates of set of genes into vectors. — create_genesets","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"Convert coordinates set genes vectors.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"","code":"create_genesets(   x,   name_lst,   cluster_info,   sample_names,   bin_type,   bin_param,   use_cm = FALSE,   n_cores = 1 )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"x named list (transcript detection coordinates) SingleCellExperiment SpatialExperiment SpatialFeatureExperiment object. named list provided, every list element dataframe containing transcript detection coordinates column names must include \"feature_name\" (nagative control name), \"x\" (x coordinate)  \"y\" (y coordinate). list names must match samples cluster_info. name_lst named list strings giving name features treated background. cluster_info dataframe/matrix containing centroid coordinates, cluster sample label cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). sample_names vector strings giving sample names bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . use_cm boolean value specifies whether create spatial vectors genes using count matrix cell coordinates instead transcript coordinates types information available. default setting FALSE. n_cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing).","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"list two matrices following components gene_mt contains transcript count grid. row refers grid, column refers gene. cluster_mt contains number cells specific cluster grid. row refers grid, column refers cluster. row order gene_mt matches row order cluster_mt. matrix contains sum count grid. row refers grid, column refers set name_lst. column name match names name_lst.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"","code":"library(SpatialExperiment) set.seed(15) trans = as.data.frame(rbind(cbind(x = runif(10, min=1, max=10),                          y = runif(10, min=1, max=10),                                 feature_name=\"A\"),                          cbind(x = runif(5, min=10, max=24),                                y = runif(5, min=1, max=10),                                feature_name=\"B\"),                          cbind(x = runif(10, min=10, max=24),                                y = runif(10, min=10, max=24),                                feature_name=\"C\"))) trans$x = as.numeric(trans$x) trans$y = as.numeric(trans$y) trans$cell = sample(c(\"cell1\",\"cell2\",\"cell2\"),replace=TRUE,                         size=nrow(trans)) # create SpatialExperiment object trans_mol <- BumpyMatrix::splitAsBumpyMatrix(     trans[, c(\"x\", \"y\")],      row = trans$feature_name, col = trans$cell ) rep1_spe<- SpatialExperiment(      assays = list(molecules = trans_mol),sample_id =\"sample1\" ) geneset_res <- create_genesets(x=rep1_spe, sample=c(\"sample1\"),                              name_lst=list(dummy_A=c(\"A\",\"C\"),                                              dummy_B=c(\"A\",\"B\",\"C\")),                              bin_type=\"square\",                              bin_param=c(2,2),cluster_info=NULL)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_binning.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to check the input of binning — .check_binning","title":"helper function to check the input of binning — .check_binning","text":"helper function check input binning","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_binning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to check the input of binning — .check_binning","text":"","code":".check_binning(bin_param, bin_type, range_list)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_binning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to check the input of binning — .check_binning","text":"bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . example: c(3, 4) means 3 bins along x-axis 4 bins       along y-axis (3 × 4 grid). c(5, 5) means 5 bins along x-axis 5 bins       along y-axis (5 × 5 grid). bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". range_list named list spatial ranges sample. element list two components: w_x w_y, numeric vectors length 2 specifying x- y-axis ranges (e.g., cell transcript coordinates). range calculated 5 within window.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_binning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to check the input of binning — .check_binning","text":"length total bins","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_input.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to check the inputs passed to marker detection function — .check_valid_input","title":"helper function to check the inputs passed to marker detection function — .check_valid_input","text":"helper function check inputs passed marker detection function","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to check the inputs passed to marker detection function — .check_valid_input","text":"","code":".check_valid_input(   gene_mt,   cluster_mt,   sample_names,   n_fold = 10,   background = NULL )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to check the inputs passed to marker detection function — .check_valid_input","text":"gene_mt matrix contains transcript count grid. row refers grid, column refers gene. column names must specified refer genes. can output function get_vectors. cluster_mt matrix contains number cells specific cluster grid. row refers grid, column refers cluster. column names must specified refer clusters. Please assign integers column names. can output function get_vectors. sample_names vector specifying names samples. n_fold Optional. positive number giving number folds used cross validation. parameter pass cv.glmnet calculate penalty term every gene. background Optional. matrix providing background information. row refers grid, column refers one category background information. Number rows must equal number rows gene_mt cluster_mt. Can obtained providing coordinates matrices cluster_info. function get_vectors.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to check the inputs passed to marker detection function — .check_valid_input","text":"list two matrices following components n_clusters Number clusters cluster_names vector strings giving name clusters","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_names.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to check the names of gene/cluster/sample — .check_valid_names","title":"helper function to check the names of gene/cluster/sample — .check_valid_names","text":"helper function check names gene/cluster/sample","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_names.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to check the names of gene/cluster/sample — .check_valid_names","text":"","code":".check_valid_names(x, x_name)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_names.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to check the names of gene/cluster/sample — .check_valid_names","text":"x character vector check naming x_name name specifying type x, message purpose ","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-check_valid_names.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to check the names of gene/cluster/sample — .check_valid_names","text":"character vector length valid names","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_observation.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute observation statistic for permutation framework — .compute_observation","title":"Compute observation statistic for permutation framework — .compute_observation","text":"Compute observation statistic permutation framework","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_observation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute observation statistic for permutation framework — .compute_observation","text":"","code":".compute_observation(   x,   cluster_info,   correlation_method,   n_cores,   test_genes,   bin_type,   bin_param,   use_cm )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_observation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute observation statistic for permutation framework — .compute_observation","text":"x named list (transcript detection coordinates) SingleCellExperiment SpatialExperiment SpatialFeatureExperiment object. named list provided, every list element dataframe containing transcript detection coordinates column names must include \"feature_name\" (gene name), \"x\" (x coordinate), \"y\" (y coordinate). list names must match samples cluster_info. cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). strongly recommended use syntactically valid names columns clusters samples. invalid names detected, function make.names employed generate valid names. message also displayed indicate change. correlation_method parameter pass cor, indicating correlation coefficient computed. One \"pearson\" (default), \"kendall\", \"spearman\": can abbreviated. n_cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing). test_genes vector strings giving name genes want test correlation . bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . use_cm boolean value specifies whether create spatial vectors genes using count matrix cell coordinates instead transcript coordinates types information available. default setting FALSE.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_observation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute observation statistic for permutation framework — .compute_observation","text":"named list following components obs.stat matrix contains observation statistic every gene every cluster. row refers gene, column refers cluster gene_mt contains transcript count grid. row refers grid, column refers gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_permutation.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute permutation statistics for permutation framework — .compute_permutation","title":"Compute permutation statistics for permutation framework — .compute_permutation","text":"Compute permutation statistics permutation framework","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_permutation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute permutation statistics for permutation framework — .compute_permutation","text":"","code":".compute_permutation(   cluster_info,   perm.size = 1000,   correlation_method = \"pearson\",   bin_type,   bin_param,   n_cores = 1,   gene_mt,   cluster_names,   window_range )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_permutation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute permutation statistics for permutation framework — .compute_permutation","text":"cluster_info dataframe/matrix containing centroid coordinates cluster label cell.column names include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label). perm.size positive number specifying permutation times correlation_method parameter pass cor, indicating correlation coefficient computed. One \"pearson\" (default), \"kendall\", \"spearman\": can abbreviated. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . n_cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing). gene_mt matrix contains transcript count grid. row refers grid, column refers gene. cluster_names list strings giving name order clusters window_range  list spatial ranges x y. list contains two components: w_x w_y, numeric vectors length 2 specifying x- y-axis ranges (e.g., cell transcript coordinates).","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-compute_permutation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute permutation statistics for permutation framework — .compute_permutation","text":"matrix permutation statistics","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-convert_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — .convert_data","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — .convert_data","text":"function takes object class SingleCellExperiment, SpatialExperiment SpatialFeatureExperimentreturns returns list object expected get_vector functions.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-convert_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — .convert_data","text":"","code":".convert_data(x, sample_names, test_genes)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-convert_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — .convert_data","text":"x SingleCellExperiment SpatialExperiment SpatialFeatureExperiment object sample_names vector strings giving sample names test_genes vector strings giving name genes want create gene vector.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-convert_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — .convert_data","text":"outputs list object following components trans_lst list named dataframes. dataframe refers one sample shows transcript detection coordinates gene. name matches input sample_names cm_lst list named dataframes containing count matrix sample. name matches input sample_names","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_cor_mg_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a marker gene result object for correlation approach — .create_cor_mg_result","title":"Create a marker gene result object for correlation approach — .create_cor_mg_result","text":"function creates structured output object named 'cor_mg_result' storing permutation results. object contains three matrices:","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_cor_mg_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a marker gene result object for correlation approach — .create_cor_mg_result","text":"","code":".create_cor_mg_result(obs.stat, perm.pval, perm.pval.adj)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_cor_mg_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a marker gene result object for correlation approach — .create_cor_mg_result","text":"obs.stat matrix containing correlation coefficients pair genes cluster vectors. perm.pval matrix containing raw permutation p-value pair genes cluster. perm.pval.adj matrix containing adjusted permutation p-value pair genes cluster.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_cor_mg_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a marker gene result object for correlation approach — .create_cor_mg_result","text":"S3 object class 'cor_mg_result' includes three matrices.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_lm_mg_result.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a marker gene result object for linear modelling approach — .create_lm_mg_result","title":"Create a marker gene result object for linear modelling approach — .create_lm_mg_result","text":"function creates structured output object named 'glm_mg_result' storing marker gene results. object contains two data frames: top results full results.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_lm_mg_result.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a marker gene result object for linear modelling approach — .create_lm_mg_result","text":"","code":".create_lm_mg_result(top_result, full_result)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_lm_mg_result.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a marker gene result object for linear modelling approach — .create_lm_mg_result","text":"top_result data frame containing top results. full_result data frame containing full results.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-create_lm_mg_result.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a marker gene result object for linear modelling approach — .create_lm_mg_result","text":"S3 object class 'glm_mg_result' includes results data frames.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_cluster_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial vectors for clusters — .get_cluster_vectors","title":"Create spatial vectors for clusters — .get_cluster_vectors","text":"Create spatial vectors clusters","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_cluster_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial vectors for clusters — .get_cluster_vectors","text":"","code":".get_cluster_vectors(   cluster_info,   bin_length,   bin_type,   bin_param,   range_list,   sample_names )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_cluster_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial vectors for clusters — .get_cluster_vectors","text":"cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). bin_length positive integer giving length total bins bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . example: c(3, 4) means 3 bins along x-axis 4 bins       along y-axis (3 × 4 grid). c(5, 5) means 5 bins along x-axis 5 bins       along y-axis (5 × 5 grid). range_list named list spatial ranges sample. element list two components: w_x w_y, numeric vectors length 2 specifying x- y-axis ranges (e.g., cell transcript coordinates). range calculated 5 within window. sample_names vector strings giving sample names","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_cluster_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial vectors for clusters — .get_cluster_vectors","text":"matrix contains cell count grid. row refers grid, column refers cluster.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_cm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial vectors for genes from count matrix and cell coordinates — .get_gene_vectors_cm","title":"Create spatial vectors for genes from count matrix and cell coordinates — .get_gene_vectors_cm","text":"function build gene vectors count matrix cell locations","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_cm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial vectors for genes from count matrix and cell coordinates — .get_gene_vectors_cm","text":"","code":".get_gene_vectors_cm(   cluster_info,   cm_lst,   bin_type,   bin_param,   test_genes,   range_list )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_cm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial vectors for genes from count matrix and cell coordinates — .get_gene_vectors_cm","text":"cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). cm_lst list named matrices containing count matrix sample name must match sample column cluster_info. input provided, cluster_info must specified contain additional column \"cell_id\" link cell location count matrix. Default NULL. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . example: c(3, 4) means 3 bins along x-axis 4 bins       along y-axis (3 × 4 grid). c(5, 5) means 5 bins along x-axis 5 bins       along y-axis (5 × 5 grid). test_genes vector strings giving name genes want test. used column names one result matrix gene_mt. range_list named list spatial ranges sample. element list two components: w_x w_y, numeric vectors length 2 specifying x- y-axis ranges (e.g., cell transcript coordinates). range calculated 5 within window.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_cm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial vectors for genes from count matrix and cell coordinates — .get_gene_vectors_cm","text":"matrix contains transcript count grid. row refers grid, column refers gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_tr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial vectors for genes from transcript coordinates — .get_gene_vectors_tr","title":"Create spatial vectors for genes from transcript coordinates — .get_gene_vectors_tr","text":"function build gene vectors based transcript coordinates every gene","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_tr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial vectors for genes from transcript coordinates — .get_gene_vectors_tr","text":"","code":".get_gene_vectors_tr(   trans_lst,   test_genes,   bin_type,   bin_param,   bin_length,   range_list )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_tr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial vectors for genes from transcript coordinates — .get_gene_vectors_tr","text":"trans_lst specified, list named dataframes. dataframe refers one sample shows transcript detection coordinates gene. Optional parameter. test_genes vector strings giving name genes want test. used column names one result matrix gene_mt. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . example: c(3, 4) means 3 bins along x-axis 4 bins       along y-axis (3 × 4 grid). c(5, 5) means 5 bins along x-axis 5 bins       along y-axis (5 × 5 grid). bin_length positive integer giving length total bins range_list named list spatial ranges sample. element list two components: w_x w_y, numeric vectors length 2 specifying x- y-axis ranges (e.g., cell transcript coordinates). range calculated 5 within window.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_gene_vectors_tr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial vectors for genes from transcript coordinates — .get_gene_vectors_tr","text":"matrix contains transcript count grid. row refers grid, column refers gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_lasso_coef.html","id":null,"dir":"Reference","previous_headings":"","what":"help function to get lasso coefficient for every cluster for a given model — .get_lasso_coef","title":"help function to get lasso coefficient for every cluster for a given model — .get_lasso_coef","text":"help function get lasso coefficient every cluster given model","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_lasso_coef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"help function to get lasso coefficient for every cluster for a given model — .get_lasso_coef","text":"","code":".get_lasso_coef(   i_gene,   gene_mt,   vec_cluster,   cluster_names,   n_fold = 10,   n_samples,   sample_names )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_lasso_coef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"help function to get lasso coefficient for every cluster for a given model — .get_lasso_coef","text":"i_gene Name current gene gene_mt matrix contains transcript count grid. row refers grid, column refers gene. column names must specified refer genes. can output function get_vectors. vec_cluster matrix spatial vectors clusters. cluster_names vector strings giving name clusters n_fold Optional. positive number giving number folds used cross validation. parameter pass cv.glmnet calculate penalty term every gene. n_samples positive number giving number samples sample_names vector specifying names sample","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/dot-get_lasso_coef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"help function to get lasso coefficient for every cluster for a given model — .get_lasso_coef","text":"list two matrices following components coef_df matrix giving lasso coefficient cluster lambda.1se lambda.1se value best fitted model","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cor.html","id":null,"dir":"Reference","previous_headings":"","what":"Get observed correlation cor_mg_result — get_cor","title":"Get observed correlation cor_mg_result — get_cor","text":"Accessor function retrieve observed correlation 'cor_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cor.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get observed correlation cor_mg_result — get_cor","text":"","code":"get_cor(obj)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cor.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get observed correlation cor_mg_result — get_cor","text":"obj 'cor_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cor.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get observed correlation cor_mg_result — get_cor","text":"matrix contains observation statistic every gene every cluster. row refers gene, column refers cluster","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cor.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get observed correlation cor_mg_result — get_cor","text":"","code":"library(SpatialExperiment) library(BumpyMatrix) set.seed(100) # simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=10, mean=20, sd=5),                     y = rnorm(n=10, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=10, mean=100, sd=5),                     y = rnorm(n=10, mean=100, sd=5), cluster=\"B\") clusters <- rbind(df_clA, df_clB) clusters$sample=\"sample1\" # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A1\"),                     cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A2\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B1\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell =  rep(paste(\"cell\",1:20, sep=\"\"), times=2) mol <- BumpyMatrix::splitAsBumpyMatrix(      trans_info[, c(\"x\", \"y\")],       row = trans_info$feature_name, col = trans_info$cell ) spe_sample1 <- SpatialExperiment(         assays = list(molecules = mol),sample_id =\"sample1\" ) set.seed(100) corr_res <- compute_permp(x=spe_sample1,              cluster_info=clusters,              perm.size=10,              bin_type=\"square\",              bin_param=c(2,2),              test_genes=unique(trans_info$feature_name),              correlation_method = \"pearson\",              n_cores=1,              correction_method=\"BH\") #> Correlation Method = pearson #> Running 10 permutation in sequential # observed correlation  obs_corr <- get_cor(corr_res)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_full_mg.html","id":null,"dir":"Reference","previous_headings":"","what":"Get full lasso result from glm_mg_result — get_full_mg","title":"Get full lasso result from glm_mg_result — get_full_mg","text":"Accessor function retrieve 'full_result' dataframe 'glm_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_full_mg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get full lasso result from glm_mg_result — get_full_mg","text":"","code":"get_full_mg(obj, coef_cutoff = 0)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_full_mg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get full lasso result from glm_mg_result — get_full_mg","text":"obj 'glm_mg_result' object. coef_cutoff positive number giving coefficient cutoff value. Genes whose cluster showing coefficient value smaller cutoff removed. Default 0.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_full_mg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get full lasso result from glm_mg_result — get_full_mg","text":"data frame detailed information gene relevant cluster label. gene Gene name cluster name significant cluster glm_coef coefficient selected cluster generalised linear model. pearson Pearson correlation gene vector selected cluster vector. max_gg_corr number showing maximum pearson correlation gene vector gene vectors input gene_mt max_gc_corr number showing maximum pearson correlation gene vector every cluster vectors input cluster_mt","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_full_mg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get full lasso result from glm_mg_result — get_full_mg","text":"","code":"library(SpatialExperiment) set.seed(100) #  simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=100, mean=20, sd=5),                  y = rnorm(n=100, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=100, mean=100, sd=5),                 y = rnorm(n=100, mean=100, sd=5), cluster=\"B\")  clusters <- rbind(df_clA, df_clB) clusters$sample<-\"sample1\"  # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=100, mean=20,sd=5),                                 y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A1\"),                            cbind(x = rnorm(n=100, mean=20, sd=5),                                  y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A2\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B1\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell<-sample(c(\"cell1\",\"cell2\",\"cell2\"),replace=TRUE,                         size=nrow(trans_info)) trans_mol <- BumpyMatrix::splitAsBumpyMatrix(     trans_info[, c(\"x\", \"y\")],      row = trans_info$feature_name, col = trans_info$cell ) spe<- SpatialExperiment(      assays = list(molecules = trans_mol),sample_id =\"sample1\" ) vecs_lst <- get_vectors(x=spe,sample_names=c(\"sample1\"),                     cluster_info = clusters,                     bin_type = \"square\",                     bin_param = c(20,20),                     test_genes =c(\"gene_A1\",\"gene_A2\",\"gene_B1\",\"gene_B2\")) #> Warning: 1 point was rejected as lying outside the specified window lasso_res <- lasso_markers(gene_mt=vecs_lst$gene_mt,                         cluster_mt = vecs_lst$cluster_mt,                         sample_names=c(\"sample1\"),                         keep_positive=TRUE,                         background=NULL) # the full result full_result <- get_full_mg(lasso_res, coef_cutoff=0.05)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_adjp.html","id":null,"dir":"Reference","previous_headings":"","what":"Get permutation adjusted p value from cor_mg_result — get_perm_adjp","title":"Get permutation adjusted p value from cor_mg_result — get_perm_adjp","text":"Accessor function retrieve permutation adjusted p-value 'cor_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_adjp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get permutation adjusted p value from cor_mg_result — get_perm_adjp","text":"","code":"get_perm_adjp(obj)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_adjp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get permutation adjusted p value from cor_mg_result — get_perm_adjp","text":"obj 'cor_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_adjp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get permutation adjusted p value from cor_mg_result — get_perm_adjp","text":"matrix contains adjusted permutation p-value. row refers gene, column refers cluster.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_adjp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get permutation adjusted p value from cor_mg_result — get_perm_adjp","text":"","code":"library(SpatialExperiment) library(BumpyMatrix) set.seed(100) # simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=10, mean=20, sd=5),                     y = rnorm(n=10, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=10, mean=100, sd=5),                     y = rnorm(n=10, mean=100, sd=5), cluster=\"B\") clusters <- rbind(df_clA, df_clB) clusters$sample=\"sample1\" # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A1\"),                     cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A2\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B1\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell =  rep(paste(\"cell\",1:20, sep=\"\"), times=2) mol <- BumpyMatrix::splitAsBumpyMatrix(      trans_info[, c(\"x\", \"y\")],       row = trans_info$feature_name, col = trans_info$cell ) spe_sample1 <- SpatialExperiment(         assays = list(molecules = mol),sample_id =\"sample1\" ) set.seed(100) corr_res <- compute_permp(x=spe_sample1,              cluster_info=clusters,              perm.size=10,              bin_type=\"square\",              bin_param=c(2,2),              test_genes=unique(trans_info$feature_name),              correlation_method = \"pearson\",              n_cores=1,              correction_method=\"BH\") #> Correlation Method = pearson #> Running 10 permutation in sequential # adjusted permutation p-value adjusted_perm_p <- get_perm_adjp(corr_res)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_p.html","id":null,"dir":"Reference","previous_headings":"","what":"Get permutation p value from cor_mg_result — get_perm_p","title":"Get permutation p value from cor_mg_result — get_perm_p","text":"Accessor function retrieve raw permutation p-value 'cor_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_p.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get permutation p value from cor_mg_result — get_perm_p","text":"","code":"get_perm_p(obj)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_p.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get permutation p value from cor_mg_result — get_perm_p","text":"obj 'cor_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_p.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get permutation p value from cor_mg_result — get_perm_p","text":"matrix contains raw permutation p-value. row refers gene, column refers cluster.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_perm_p.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get permutation p value from cor_mg_result — get_perm_p","text":"","code":"library(SpatialExperiment) library(BumpyMatrix) set.seed(100) # simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=10, mean=20, sd=5),                     y = rnorm(n=10, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=10, mean=100, sd=5),                     y = rnorm(n=10, mean=100, sd=5), cluster=\"B\") clusters <- rbind(df_clA, df_clB) clusters$sample<-\"sample1\" # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A1\"),                     cbind(x = rnorm(n=10, mean=20, sd=5),                                     y = rnorm(n=10, mean=20, sd=5),                                     feature_name=\"gene_A2\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B1\"),                     cbind(x = rnorm(n=10, mean=100, sd=5),                                     y = rnorm(n=10, mean=100, sd=5),                                     feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell =  rep(paste(\"cell\",1:20, sep=\"\"), times=2) mol <- BumpyMatrix::splitAsBumpyMatrix(      trans_info[, c(\"x\", \"y\")],       row = trans_info$feature_name, col = trans_info$cell ) spe_sample1 <- SpatialExperiment(         assays = list(molecules = mol),sample_id =\"sample1\" ) set.seed(100) corr_res <- compute_permp(x=spe_sample1,              cluster_info=clusters,              perm.size=10,              bin_type=\"square\",              bin_param=c(2,2),              test_genes=unique(trans_info$feature_name),              correlation_method = \"pearson\",              n_cores=1,              correction_method=\"BH\") #> Correlation Method = pearson #> Running 10 permutation in sequential               # raw permutation p-value perm_p <- get_perm_p(corr_res)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_top_mg.html","id":null,"dir":"Reference","previous_headings":"","what":"Get top lasso result from glm_mg_result — get_top_mg","title":"Get top lasso result from glm_mg_result — get_top_mg","text":"Accessor function retrieve 'top_result' dataframe 'glm_mg_result' object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_top_mg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Get top lasso result from glm_mg_result — get_top_mg","text":"","code":"get_top_mg(obj, coef_cutoff = 0.05)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_top_mg.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Get top lasso result from glm_mg_result — get_top_mg","text":"obj 'glm_mg_result' object. coef_cutoff positive number giving coefficient cutoff value. Genes whose top cluster showing coefficient value smaller cutoff marked non-marker genes (\"NoSig\"). Default 0.05.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_top_mg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Get top lasso result from glm_mg_result — get_top_mg","text":"data frame detailed information gene relevant cluster label. gene Gene name top_cluster name relevant cluster thresholding coefficients. glm_coef coefficient selected cluster generalised linear model. pearson Pearson correlation gene vector selected cluster vector. max_gg_corr number showing maximum pearson correlation gene vector gene vectors input gene_mt max_gc_corr number showing maximum pearson correlation gene vector every cluster vectors input cluster_mt","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_top_mg.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Get top lasso result from glm_mg_result — get_top_mg","text":"","code":"library(SpatialExperiment) set.seed(100) #  simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=100, mean=20, sd=5),                  y = rnorm(n=100, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=100, mean=100, sd=5),                 y = rnorm(n=100, mean=100, sd=5), cluster=\"B\")  clusters <- rbind(df_clA, df_clB) clusters$sample<-\"sample1\"  # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=100, mean=20,sd=5),                                 y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A1\"),                            cbind(x = rnorm(n=100, mean=20, sd=5),                                  y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A2\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B1\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell<-sample(c(\"cell1\",\"cell2\",\"cell2\"),replace=TRUE,                         size=nrow(trans_info)) trans_mol <- BumpyMatrix::splitAsBumpyMatrix(     trans_info[, c(\"x\", \"y\")],      row = trans_info$feature_name, col = trans_info$cell ) spe<- SpatialExperiment(      assays = list(molecules = trans_mol),sample_id =\"sample1\" ) vecs_lst <- get_vectors(x=spe,sample_names=c(\"sample1\"),                     cluster_info = clusters,                     bin_type = \"square\",                     bin_param = c(20,20),                     test_genes =c(\"gene_A1\",\"gene_A2\",\"gene_B1\",\"gene_B2\")) #> Warning: 1 point was rejected as lying outside the specified window lasso_res <- lasso_markers(gene_mt=vecs_lst$gene_mt,                         cluster_mt = vecs_lst$cluster_mt,                         sample_names=c(\"sample1\"),                         keep_positive=TRUE,                         background=NULL) # the top result top_result<- get_top_mg(lasso_res, coef_cutoff=0.05)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorise the spatial coordinates — get_vectors","title":"Vectorise the spatial coordinates — get_vectors","text":"function convert coordinates numeric vector genes clusters.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorise the spatial coordinates — get_vectors","text":"","code":"get_vectors(   x,   cluster_info,   sample_names,   bin_type,   bin_param,   test_genes,   use_cm = FALSE,   n_cores = 1,   return_boundary = FALSE )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorise the spatial coordinates — get_vectors","text":"x named list (transcript detection coordinates) SingleCellExperiment SpatialExperiment SpatialFeatureExperiment object. named list provided, every list element dataframe containing transcript detection coordinates column names must include \"feature_name\" (gene name), \"x\" (x coordinate), \"y\" (y coordinate). list names must match samples cluster_info. cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). strongly recommended use syntactically valid names columns clusters samples. invalid names detected, function make.names employed generate valid names. message also displayed indicate change. sample_names vector strings giving sample names. strongly recommended use syntactically valid names columns clusters samples. invalid names detected, function make.names employed generate valid names. message also displayed indicate change. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . example: c(3, 4) means 3 bins along x-axis 4 bins       along y-axis (3 × 4 grid). c(5, 5) means 5 bins along x-axis 5 bins       along y-axis (5 × 5 grid). test_genes vector strings giving name genes want create gene vector. used column names one result matrix gene_mt. use_cm boolean value specifies whether create spatial vectors genes using count matrix cell coordinates instead transcript coordinates types information available. default setting FALSE. n_cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing). return_boundary Logical. TRUE, return x- y-coordinate limits (`xrange`, `yrange`) enclosing box sample addition main result. default setting FALSE.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorise the spatial coordinates — get_vectors","text":"list two matrices following components gene_mt contains transcript count grid. row refers grid, column refers gene. cluster_mt contains number cells specific cluster grid. row refers grid, column refers cluster. row order gene_mt matches row order cluster_mt. boundary (optional) Returned return_boundary = TRUE. list containing x- y-coordinate limits enclosing box sample.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorise the spatial coordinates — get_vectors","text":"function can used generate input lasso_markers specifying parameters. Suppose input data contains \\(n\\) genes, \\(c\\) clusters, \\(k\\) samples, want use \\(\\times \\) square bin convert coordinates genes clusters 1d vectors. \\(k=1\\), returned list contain one matrix gene vectors (gene_mt) dimension \\(^2 \\times n\\) one matrix cluster vectors (cluster_mt) dimension \\(^2 \\times c\\). \\(k>1\\), gene cluster vectors constructed sample separately concat together. additional k columns returned cluster_mt, one-hot encoding sample information. Moreover, function can vectorise genes clusters separately based input. x NULL, function return vectorised clusters based cluster_info. cluster_info NULL, function return vectorised genes based x.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorise the spatial coordinates — get_vectors","text":"","code":"library(SpatialExperiment) set.seed(100) #  simulate coordinates for clusters df_clA = data.frame(x = rnorm(n=100, mean=20, sd=5),                  y = rnorm(n=100, mean=20, sd=5), cluster=\"A\") df_clB = data.frame(x = rnorm(n=100, mean=100, sd=5),                 y = rnorm(n=100, mean=100, sd=5), cluster=\"B\")  clusters = rbind(df_clA, df_clB) clusters$sample=\"sample1\"  # simulate coordinates for genes trans_info = data.frame(rbind(cbind(x = rnorm(n=10, mean=20,sd=5),                                 y = rnorm(n=10, mean=20, sd=5),                                  feature_name=\"gene_A1\"),                            cbind(x = rnorm(n=10, mean=20, sd=5),                                  y = rnorm(n=10, mean=20, sd=5),                                  feature_name=\"gene_A2\"),                            cbind(x = rnorm(n=10, mean=100, sd=5),                                  y = rnorm(n=10, mean=100, sd=5),                                  feature_name=\"gene_B1\"),                            cbind(x = rnorm(n=10, mean=100, sd=5),                                  y = rnorm(n=10, mean=100, sd=5),                                  feature_name=\"gene_B2\"))) trans_info$x=as.numeric(trans_info$x) trans_info$y=as.numeric(trans_info$y) trans_info$cell = sample(c(\"cell1\",\"cell2\",\"cell2\"),replace=TRUE,                         size=nrow(trans_info)) # use named list as input vecs_lst = get_vectors(x= list(\"sample1\" = trans_info),                     sample_names=c(\"sample1\"),                     cluster_info = clusters,                     bin_type = \"square\",                     bin_param = c(5,5),                     test_genes =c(\"gene_A1\",\"gene_A2\",\"gene_B1\",\"gene_B2\")) #> Warning: 1 point was rejected as lying outside the specified window #> Warning: 6 points were rejected as lying outside the specified window # use SpatialExperiment object as input trans_mol <- BumpyMatrix::splitAsBumpyMatrix(     trans_info[, c(\"x\", \"y\")],      row = trans_info$feature_name, col = trans_info$cell ) spe<- SpatialExperiment(      assays = list(molecules = trans_mol),sample_id =\"sample1\" ) vecs_lst_spe = get_vectors(x=spe,sample_names=c(\"sample1\"),                     cluster_info = clusters,                     bin_type = \"square\",                     bin_param = c(5,5),                     test_genes =c(\"gene_A1\",\"gene_A2\",\"gene_B1\",\"gene_B2\")) #> Warning: 1 point was rejected as lying outside the specified window #> Warning: 6 points were rejected as lying outside the specified window"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/jazzPanda-package.html","id":null,"dir":"Reference","previous_headings":"","what":"jazzPanda: A hybrid approach to find spatially relevant marker genes in image-based spatial transcriptomics data — jazzPanda-package","title":"jazzPanda: A hybrid approach to find spatially relevant marker genes in image-based spatial transcriptomics data — jazzPanda-package","text":"jazzPanda pacakge provides hybrid approaches prioritize marker genes uses spatial coordinates gene detections cells making clusters. propose binning approach get_vectors summarises number genes cells within cluster spatial vectors. developed two approaches detect prioritize marker genes. first approach compute_permp based correlation coefficients genes cluster spatial vectors, significance marker genes assessed permutation. second approach lasso_markers based lasso regularisation linear modeling defined spatial vectors. second approach flexible can account multiple samples background noise.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/jazzPanda-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"jazzPanda: A hybrid approach to find spatially relevant marker genes in image-based spatial transcriptomics data — jazzPanda-package","text":"Melody Jin jin.m@wehi.edu.au","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":null,"dir":"Reference","previous_headings":"","what":"Find marker genes with spatial coordinates — lasso_markers","title":"Find marker genes with spatial coordinates — lasso_markers","text":"function find spatially relevant cluster label gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find marker genes with spatial coordinates — lasso_markers","text":"","code":"lasso_markers(   gene_mt,   cluster_mt,   sample_names,   keep_positive = TRUE,   background = NULL,   n_fold = 10 )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find marker genes with spatial coordinates — lasso_markers","text":"gene_mt matrix contains transcript count grid. row refers grid, column refers gene. column names must specified refer genes. can output function get_vectors. cluster_mt matrix contains number cells specific cluster grid. row refers grid, column refers cluster. column names must specified refer clusters. Please assign integers column names. can output function get_vectors. sample_names vector specifying names samples. keep_positive logical flag indicating whether return positively correlated clusters . background Optional. matrix providing background information. row refers grid, column refers one category background information. Number rows must equal number rows gene_mt cluster_mt. Can obtained providing coordinates matrices cluster_info. function get_vectors. n_fold Optional. positive number giving number folds used cross validation. parameter pass cv.glmnet calculate penalty term every gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find marker genes with spatial coordinates — lasso_markers","text":"object class 'glm_mg_result' access specific components returned object: Use get_top_mg retrieve top result data frame Use get_full_mg retrieve full result data frame","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find marker genes with spatial coordinates — lasso_markers","text":"function take converted gene cluster vectors function get_vectors, return relevant cluster label gene. multiple samples dataset, function find shared markers across different samples including additional sample vectors input cluster_mt. function treats input cluster vectors features, create penalized linear model one gene vector lasso regularization. Clusters non-zero coefficient selected, clusters used formulate generalised linear model gene vector. input keep_positive TRUE, clusters positive coefficient significant p-value saved output matrix lasso_full_result. cluster positive coefficient minimum p-value regarded relevant cluster gene saved output matrix lasso_result. input keep_positive FALSE, clusters negative coefficient significant p-value saved output matrix lasso_full_result. cluster negative coefficient minimum p-value regarded relevant cluster gene saved output matrix lasso_result. clusters significant p-value, string \"NoSig\" returned gene. parameter background can used capture unwanted noise pattern dataset. example, can include negative control genes background cluster model. relevant cluster selected one gene matches background \"clusters\", return \"NoSig\" gene.","code":""},{"path":[]},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find marker genes with spatial coordinates — lasso_markers","text":"","code":"library(SpatialExperiment) set.seed(100) #  simulate coordinates for clusters df_clA <- data.frame(x = rnorm(n=100, mean=20, sd=5),                  y = rnorm(n=100, mean=20, sd=5), cluster=\"A\") df_clB <- data.frame(x = rnorm(n=100, mean=100, sd=5),                 y = rnorm(n=100, mean=100, sd=5), cluster=\"B\")  clusters <- rbind(df_clA, df_clB) clusters$sample<-\"sample1\"  # simulate coordinates for genes trans_info <- data.frame(rbind(cbind(x = rnorm(n=100, mean=20,sd=5),                                 y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A1\"),                            cbind(x = rnorm(n=100, mean=20, sd=5),                                  y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A2\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B1\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B2\"))) trans_info$x<-as.numeric(trans_info$x) trans_info$y<-as.numeric(trans_info$y) trans_info$cell<-sample(c(\"cell1\",\"cell2\",\"cell2\"),replace=TRUE,                         size=nrow(trans_info)) trans_mol <- BumpyMatrix::splitAsBumpyMatrix(     trans_info[, c(\"x\", \"y\")],      row = trans_info$feature_name, col = trans_info$cell ) spe<- SpatialExperiment(      assays = list(molecules = trans_mol),sample_id =\"sample1\" ) vecs_lst <- get_vectors(x=spe,sample_names=c(\"sample1\"),                     cluster_info = clusters,                     bin_type = \"square\",                     bin_param = c(20,20),                     test_genes =c(\"gene_A1\",\"gene_A2\",\"gene_B1\",\"gene_B2\")) #> Warning: 1 point was rejected as lying outside the specified window lasso_res <- lasso_markers(gene_mt=vecs_lst$gene_mt,                         cluster_mt = vecs_lst$cluster_mt,                         sample_names=c(\"sample1\"),                         keep_positive=TRUE,                         background=NULL) # the top result top_result <- get_top_mg(lasso_res, coef_cutoff=0.05) # the full result full_result <- get_full_mg(lasso_res, coef_cutoff=0.05)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep1 selected cells — rep1_clusters","title":"Rep1 selected cells — rep1_clusters","text":"data frame file containing coordinates cluster label cell selected subset rep1.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep1 selected cells — rep1_clusters","text":"","code":"data(rep1_clusters)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep1 selected cells — rep1_clusters","text":"data frame 1705 rows 6 variables: anno provided cell type annotation cluster cluster label x x coordinates y y coordiantes cells cell id sample sample id","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep1 selected cells — rep1_clusters","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep1/ Xenium_FFPE_Human_Breast_Cancer_Rep1_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep1 selected cells — rep1_clusters","text":"data frame","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep1 negative control genes within the selected region. — rep1_neg","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"SpatialExperiment object containing coordinates every negative control detection rep1_sub","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"","code":"data(rep1_neg)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"SpatialExperiment object. molecules assay slot BumpyDataFrameMatrix obejct. Can retrieve DataFrame version calling `BumpyMatrix::unsplitAsDataFrame(molecules(rep1_neg))`. molecules slot contains: x x coordinates y y coordiantes feature_name negative control probe name category negative control category","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep1/Xenium_FFPE_Human_Breast_ Cancer_Rep1_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"SpatialExperiment","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"A small section of Xenium human breast cancer rep1. — rep1_sub","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"SpatialExperiment object containing coordinates every transcript","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"","code":"data(rep1_sub)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"SpatialExperiment object 20 genes 1713 cells. molecules assay slot BumpyDataFrameMatrix obejct. Can retrieve DataFrame version calling `BumpyMatrix::unsplitAsDataFrame(molecules(rep2_sub))`. molecules assay contains 79576 rows 3 variables: x x coordinates y y coordiantes feature_name transcript name","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep1/ Xenium_FFPE_Human_Breast_Cancer_Rep1_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"SpatialExperiment","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep2 selected cells — rep2_clusters","title":"Rep2 selected cells — rep2_clusters","text":"csv file containing coordinates cluster label cell selected subset rep2.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep2 selected cells — rep2_clusters","text":"","code":"data(rep2_clusters)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep2 selected cells — rep2_clusters","text":"data frame 1815 rows 6 variables: anno provided cell type annotation cluster cluster label x x coordinates y y coordiantes cells cell id sample sample id","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep2 selected cells — rep2_clusters","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep2/ Xenium_FFPE_Human_Breast_Cancer_Rep2_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep2 selected cells — rep2_clusters","text":"data frame","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep2 negative control genes within the selected region. — rep2_neg","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"data frame containing coordinates every negative control detection rep2","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"","code":"data(rep2_neg)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"SpatialExperiment object. molecules assay slot BumpyDataFrameMatrix obejct. Can retrieve DataFrame version calling `BumpyMatrix::unsplitAsDataFrame(molecules(rep2_neg))`. molecules slot contains: x x coordinates y y coordiantes feature_name negative control probe name category negative control category","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep2/ Xenium_FFPE_Human_Breast_Cancer_Rep2_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"SpatialExperiment","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"A small section of Xenium human breast cancer rep2. — rep2_sub","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"SpatialExperiment object containing coordinates every negative control detection rep2_sub","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"","code":"data(rep2_sub)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"SpatialExperiment object 20 genes 1829 cells. molecules assay slot BumpyDataFrameMatrix obejct. Can retrieve DataFrame version calling `BumpyMatrix::unsplitAsDataFrame(molecules(rep2_sub))`. molecules slot contains: x x coordinates y y coordiantes feature_name transcript name","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep2/ Xenium_FFPE_Human_Breast_Cancer_Rep2_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"SpatialExperiment","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-111-102-release","dir":"Changelog","previous_headings":"","what":"jazzPanda 1.1.1 (1.0.2 (release))","title":"jazzPanda 1.1.1 (1.0.2 (release))","text":"Updated Sep 1, 2025 Changes package include: - function get_vectors(): - Buffer used auto-detecting spatial windows changed 5% fixed value 1e-6. - Added new parameter allow exporting calculated bounding box sample. Buffer automatic spatial boundaries now set 1e-6. Fixed spatial bin indexing issues ensure correct alignment calcualting spatial vectors count matrix.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-101","dir":"Changelog","previous_headings":"","what":"jazzPanda 1.0.1","title":"jazzPanda 1.0.1","text":"Backported updates version 1.1.1 Bioconductor devel","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-111","dir":"Changelog","previous_headings":"","what":"jazzPanda 1.1.1","title":"jazzPanda 1.1.1","text":"Updated June 24, 2025 Changes package include: Parameters w_x w_y removed. Spatial windows now automatically determined per sample using 5% buffer around coordinate range. Improved handling genes detected subset samples. gene present sample, zero-filled vector used sample maintain consistent vector lengths across samples. Parameters w_x w_y removed. Spatial windows now computed per sample using 5% buffer based input coordinates. Improved handling genes detected subset samples. gene present sample, zero-filled vector used sample maintain consistent vector lengths across samples. Parameters w_x w_y longer required. Spatial boundaries now automatically derived per sample using 5% buffer.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-022","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.2.2","title":"jazzPanda 0.2.2","text":"Updated February 23, 2025 Changes package include: Input x can also named list now. approach enables users directly input transcript detection coordinates using dataframe. helps prevent integer overflow issues may arise creating SpatialExperiment object large dataset invalid cluster/sample names detected, function make.names() employed generate valid names. message also displayed indicate change. Input x can also named list now get_vectors()","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-021","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.2.1","title":"jazzPanda 0.2.1","text":"Updated January 20, 2025 Changes package include: Add function get_cor() Add function get_perm_p() Add function get_perm_adjp() Add function get_top_mg() Add function get_full_mg()","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-020","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.2.0","title":"jazzPanda 0.2.0","text":"Updated November 16, 2024 enhance interoperability Bioconductor, jazzPanda package updated depend following data classes: SingleCellExperiment, SpatialExperiment, SpatialFeatureExperiment. Changes package include: convert_data() function removed export list. Input trans_lst renamed x. Input cm_lst removed. x must SingleCellExperiment, SpatialExperiment, SpatialFeatureExperiment object. Renamed all_genes test_genes store genes building spatial vectors. Input data renamed x. n.cores renamed n_cores. x must SingleCellExperiment, SpatialExperiment, SpatialFeatureExperiment object. Input data_lst renamed x. x must SingleCellExperiment, SpatialExperiment, SpatialFeatureExperiment object.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-011","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.1.1","title":"jazzPanda 0.1.1","text":"Updated November 12, 2024 Add convert_data() function expand interoperability Bioconductor. Support input objects SingleCellExperiment/SpatialExperimentSpatialFeatureExperiment class Modify one input type function get_vectors(). Renamed input parameter data_lst trans_lst specifically storing transcript coordinates .","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-001","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.0.1","title":"jazzPanda 0.0.1","text":"package renamed jazzPanda","code":""}]
