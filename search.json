[{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"jazzPanda example","text":"Spatial transcriptomics allows spatial profiling complex tissue architectures. spatial arrangement interactions cells can aid understanding complex functions regulatory mechanisms various tissue micro environments. Commercially available image-based spatial technologies Xenium, CosMX, MERSCOPSE take advantage fluorescence-based microscopy quantify transcripts focus pre-designed panel genes. One crucial step analysis spatial transcriptomics data cell type annotation. number ways perform cell type annotation, marker analysis one . Marker gene analysis identify genes highly expressed cluster compared remaining clusters. identified marker genes used annotate clusters cell types. Computationally tools originally developed single cell data used spatial transcriptomics studies. However, methods ignore spatial information cells gene. limited literature developing marker gene detection methods account spatial distribution gene expression. jazzPanda provides two novel approaches detect marker genes transformed spatial information. first approach based correlation second linear modelling approach can account technical noise work studies multiple samples.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"jazzpanda-framework","dir":"Articles","previous_headings":"","what":"jazzPanda framework","title":"jazzPanda example","text":"assume marker gene show significant linear relationship target cluster tissue space. suggests transcript detection marker gene show similar patterns cells cluster tissue space. Given cluster label every cell, two steps obtain marker genes every cluster. first compute spatial vectors spatial coordinates genes clusters. , can measure linear relationship genes clusters based spatial vectors. develop two approaches detecting genes show strong linear relationship cluster. Step 1: Create spatial vectors every gene every clusterget_vectors() can used convert transcript detection cell centroids spatial vectors. can specify tile shape length based dataset. hex bins generally take longer square/rectangle bins compute. practice, find can choose length tiles average cell per tile (# cells per cluster# tiles\\frac{\\texttt{\\#}\\text{ cells per cluster} }{\\texttt{\\#}\\text{ tiles}}) close one cluster. Step 2: Detect marker genes Correlation approach: compute_permp() approach can detect marker genes one sample study. calculate correlation coefficient every pair gene cluster vector. perform permutation testing assess statistical significance calculated correlation followed multiple testing adjustment control false discovery rate. keep genes significant adjusted p-value large correlation marker genes. practice, recommend calculate correlation threshold value every cluster based data distribution. analysis, use 75% quantile value correlations given cluster cutoff manage keep meaningful marker genes. Linear modelling approach: lasso_markers() approach, treat gene vector response variable cluster vectors explanatory variables. select important cluster vectors lasso regularization first, fit linear model find cluster show minimum p-value largest model coefficient. approach can account multi-sample studies technical background noise (non-specific binding). recommend set model coefficient cutoff value based data. large cutoff value result fewer marker genes whereas small cutoff value detect marker genes. find cutoff value 0.1 0.2 work well analysis. Marker genes less 0.1 model coefficient generally weak markers. Two tables returned approach: record significant cluster gene lasso_top_result. table provides unique marker genes every cluster. Genes whose top cluster shows model coefficient smaller specified cutoff value labeled marker genes. record significant cluster gene lasso_full_result. table can used investigate shared marker genes different clusters.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"example","dir":"Articles","previous_headings":"","what":"Example","title":"jazzPanda example","text":"dataset used vignette selected subset two replicates Xenium human breast cancer tissue Sample 1. select 20 genes package illustration. subset extracted raw dataset described R script located /inst/generate_vignette_data.R. subset data used package illustration purpose . resulting marker genes may strong markers annotating clusters. Please see full analysis dataset marker genes.","code":"library(Seurat) library(ggplot2) library(jazzPanda) library(data.table) library(dplyr) library(glmnet) library(caret) library(corrplot) library(igraph) library(ggraph) library(ggrepel) library(gridExtra) library(utils) library(spatstat) library(tidyr) library(ggpubr) # ggplot style defined_theme = theme(strip.text = element_text(size = rel(1)),                         strip.background = element_rect(fill = NA,                                                      colour = \"black\"),                         axis.line=element_blank(),                         axis.text.x=element_blank(),                         axis.text.y=element_blank(),                         axis.ticks=element_blank(),                         axis.title.x=element_blank(),                         axis.title.y=element_blank(),                         legend.position=\"none\",                         panel.background=element_blank(),                         panel.border=element_blank(),                         panel.grid.major=element_blank(),                         panel.grid.minor=element_blank(),                         plot.background=element_blank())"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"load-data","dir":"Articles","previous_headings":"Example","what":"Load data","title":"jazzPanda example","text":"required input data structure main function lasso_markers() list matrices. illustrate simply create required input data raw output different technologies following examples: Seurat object, can build required object follows. defined example_vectors_cm/example_vectors_tr can passed lasso_markers identify marker genes.","code":"data(rep1_sub, rep1_clusters, rep1_neg) rep1_clusters$cluster=factor(rep1_clusters$cluster,                             levels=paste(\"c\",1:8, sep=\"\")) # record all real genes in the data all_real_genes = unique(as.character(rep1_sub$feature_name)) all_celltypes = unique(rep1_clusters[,c(\"anno\",\"cluster\")]) # nc_patterns = \"^BLANK_|^NegControlProbe_|^NegControlCodeword_|^antisense_\" # nc_targets = grep(pattern =nc_patterns , x = all_genes,value = TRUE)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-spatialexperiment-object","dir":"Articles","previous_headings":"Example > Load data","what":"From a SpatialExperiment object","title":"jazzPanda example","text":"SpatialExperiment SpatialFeatureExperiment object, can generate required input creating spatial vectors calling convert_data function. transcript coordinates available, can use either transcript coordinates count matrix define spatial vectors genes. defined example_vectors_cm/example_vectors_tr can passed lasso_markers identify marker genes.","code":"library(SpatialFeatureExperiment) library(SingleCellExperiment) library(TENxXeniumData) library(ExperimentHub) eh <- ExperimentHub() q <- query(eh, \"TENxXenium\") spe_example <- q[[\"EH8547\"]]  # get the required input list  example_lst <- convert_data(x=spe_example, sample_names = \"sample01\")  # ----------------------------------------------------------------------------- # Example clustering  # get the count matrix  cm <- spe_example@assays@data$counts all_genes = row.names(cm) example_seu <- CreateSeuratObject(counts = cm,                              min.cells = 2, min.features = 1) example_seu <- NormalizeData(example_seu,                              normalization.method = \"LogNormalize\") all.genes <- rownames(example_seu) example_seu <- ScaleData(example_seu, features = all.genes) example_seu <- RunPCA(example_seu, features = all.genes) ElbowPlot(example_seu) example_seu <- FindNeighbors(example_seu, dims = 1:15) example_seu <- FindClusters(example_seu, resolution = 0.1) seu_clusters <- as.data.frame(example_seu$seurat_clusters,nm=\"cluster\") seu_clusters$cell_id <- colnames(example_seu)  # ----------------------------------------------------------------------------- # combine cluster labels and the coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id clusters_info <- as.data.frame(spe_example@int_colData$spatialCoords) colnames(clusters_info) <- c(\"x\",\"y\") clusters_info$cell_id <- row.names(clusters_info) clusters_info$sample <- spe_example$sample_id clusters_info <- merge(clusters_info, seu_clusters, by=\"cell_id\")  w_x <- c(floor(min(clusters_info$x,                     example_lst$trans_lst$sample01$x)),         ceiling(max(clusters_info$x,                      example_lst$trans_lst$sample01$x))) w_y <- c(floor(min(clusters_info$y,                      example_lst$trans_lst$sample01$y)),         ceiling(max(clusters_info$y,                      example_lst$trans_lst$sample01$y)))  # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  example_vectors_cm <- get_vectors(trans_lst= NULL,                                 cm_lst=example_lst$cm_lst,                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = all_genes,                                 w_x=w_x, w_y=w_y)   # ----------------------------------------------------------------------------- # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr <- get_vectors(trans_lst= example_lst$trans_lst,                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = all_genes,                                 w_x=w_x, w_y=w_y)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-spatialfeatureexperiment-object","dir":"Articles","previous_headings":"Example > Load data","what":"From a SpatialFeatureExperiment object","title":"jazzPanda example","text":"","code":"sfe_example <- toSpatialFeatureExperiment(spe_example) example_sfe_lst <- convert_data(x=sfe_example,sample_names = \"sample01\") # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id example_vectors_cm <- get_vectors(trans_lst= NULL,                                 cm_lst=example_sfe_lst$cm_lst,                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = all_genes,                                 w_x=w_x, w_y=w_y)  # ----------------------------------------------------------------------------- # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr <- get_vectors(trans_lst= example_sfe_lst$trans_lst,                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = all_genes,                                 w_x=w_x, w_y=w_y)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-singlecellexperiment-object","dir":"Articles","previous_headings":"Example > Load data","what":"From a SingleCellExperiment object","title":"jazzPanda example","text":"","code":"sce_example <- SingleCellExperiment(list(sample01 = cm)) example_sce_lst <- convert_data(x=sce_example,sample_names = \"sample01\") # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id example_vectors_cm <- get_vectors(trans_lst= NULL,                                 cm_lst=example_sce_lst$cm_lst,                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = all_genes,                                 w_x=w_x, w_y=w_y)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"from-a-seurat-object","dir":"Articles","previous_headings":"Example > Load data","what":"From a Seurat object","title":"jazzPanda example","text":"","code":"# cm is the count matrix seu_obj =Seurat::CreateSeuratObject(counts = cm) # make sure the clusters information contains column names:  # cluster, x, y and sample clusters_info = rep1_clusters # make sure the transcript information contains column names:  # feature_name, x, y transcript_coords = rep1_sub$trans_info data_example = list(cm=seu_obj@assays$RNA$counts,                     trans_info =transcript_coords)  w_x =  c(min(floor(min(data$x)), floor(min(clusters_info$x))),          max(ceiling(max(data$x)), ceiling(max(clusters_info$x)))) w_y =  c(min(floor(min(data$y)), floor(min(clusters_info$y))),          max(ceiling(max(data$y)), ceiling(max(clusters_info$y))))  # build spatial vectors from transcript coordinates and cluster coordinates  example_vectors_tr = get_vectors(trans_lst= list(\"rep1\"=transcript_coords),                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = row.names(cm),                                  w_x=w_x, w_y=w_y) # ----------------------------------------------------------------------------- # build spatial vectors from count matrix and cluster coordinates  # make sure the cluster information contains column names:  # cluster, x, y, sample and cell_id colnames(clusters_info)[5] = \"cell_id\" example_vectors_cm = get_vectors(trans_lst= NULL,                                 cm_lst=list(rep1=seu_obj@assays$RNA$counts),                                 cluster_info = clusters_info,                                 bin_type=\"square\",                                 bin_param=c(10,10),                                  all_genes = row.names(cm),                                  w_x=w_x, w_y=w_y)"},{"path":[]},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"x-xenium-data","dir":"Articles","previous_headings":"Example > Load data > From direct platform output","what":"10x Xenium data","title":"jazzPanda example","text":"constructed xenium_data can used function get_vectors(). defined nc_lst can used functioncreate_genesets().","code":"path <- 'path/to/data/directory' mtx_name=\"cell_feature_matrix\" trans_name=\"transcripts.csv.gz\"  transcript_info <- as.data.frame(fread(paste(path, trans_name,sep=\"\"))) transcript_info$x <- as.numeric(transcript_info$x_location) transcript_info$y <- as.numeric(transcript_info$y_location) data <- Read10X(data.dir = paste(path,mtx_name, sep=\"\")) # count matrix  cm <- as.matrix(data$`Gene Expression`)  # negative control targets r_codeword <- as.matrix(data$`Negative Control Codeword`) r_probe <- as.matrix(data$`Negative Control Probe`)  xenium_data = list(\"sample1\" = transcript_info )  # ----------------------------------------------------------------------------- # cell label and coordinates  clusters_info <-  read.csv(\"./cells_meta.csv\") # the cluster label, sample label and coordinates for each cell  cl_req_cols <- c(\"x\",\"y\",\"cluster\",\"sample\") clusters_df <- clusters_info[,cl_req_cols]  # ----------------------------------------------------------------------------- # define negative control objects if available, need to repeat for each sample # load coordinates for each detection, must contain following columns  # - \"x\": x coordinate # - \"y\": y coordinate  # - \"target\": negative control names  # - \"sample\": sample label  probe_target <- row.names(r_probe) codeword <- row.names(r_codeword)  nc_coords = read.csv(\"./negative_controls_detections.csv\") nc_names = unique(nc_coords$feature_name) kpt_cols = c(\"x\",\"y\",\"feature_name\",\"sample\") transcript_neg = transcript_info[transcript_info$feature_name %in%                                  c(probe_target, codeword_target),                                 c(\"x_location\",\"y_location\",\"feature_name\")] colnames(transcript_neg)[1:3]= c(\"x\",\"y\",\"feature_name\") transcript_neg$sample = \"sample1\" nc_lst = list(\"sample1\" = transcript_neg)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"merscope-data","dir":"Articles","previous_headings":"Example > Load data > From direct platform output","what":"MERSCOPE data","title":"jazzPanda example","text":"constructed merscope_data can used function get_vectors(). defined nc_lst can used functioncreate_genesets().","code":"# count matrix # rows as genes and columns as cells # gene name as row names  data_p = \"path/to/merscope/output/data/\" cm = qread(\"./counts.qs\") # cell label and coordinates  clusters_info =  read.csv(\"./cells_meta.csv\")  # ----------------------------------------------------------------------------- # if transcript coordinates are available, need to repeat for each sample # load transcript data, transcripts must contain follwing columns  # - \"x\": x coordinate # - \"y\": y coordinate  # - \"feature_name\": gene name  tr_req_cols = c(\"x\", \"y\", \"feature_name\") transcript_df =  read.csv(\"./transcripts.csv\") merscope_data = list(\"sample1\" = transcript_df[,req_cols]) # the defined merscope_data can be used in function get_vectors()   # the cluster label, sample label and coordinates for each cell  cl_req_cols = c(\"x\",\"y\",\"cluster\",\"sample\") clusters_df = clusters_info[,cl_req_cols]  # ----------------------------------------------------------------------------- # define negative control objects if available, need to repeat for each sample # load coordinates for each detection, must contain following columns  # - \"x\": x coordinate # - \"y\": y coordinate  # - \"target\": negative control names  # - \"sample\": sample label  nc_coords = read.csv(\"./negative_controls_detections.csv\") nc_names = unique(nc_coords$feature_name) kpt_cols = c(\"x\",\"y\",\"feature_name\",\"sample\") nc_lst = list(\"sample1\"= nc_coords[,kpt_cols])"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"cosmx-data","dir":"Articles","previous_headings":"Example > Load data > From direct platform output","what":"CosMx data","title":"jazzPanda example","text":"constructed cosmx_data can used function get_vectors(). defined nc_lst can used functioncreate_genesets().","code":"tiledbURI <- \"file/path/to/TileDB/array/on/local/machine\"  # read in SOMACollection tiledb_scdataset <- tiledbsc::SOMACollection$new(uri = tiledbURI,                                                  verbose = FALSE) cm <- tiledb_scdataset$somas$RNA$X$members$counts$to_matrix(batch_mode = TRUE)  # the cluster label, sample label and coordinates for each cell  clusters_info <- tiledb_scdataset$somas$RNA$obs$to_dataframe()  # ----------------------------------------------------------------------------- # if transcript coordinates are available, need to repeat for each sample # load transcript data, transcripts must contain follwing columns  # - \"x\": x coordinate # - \"y\": y coordinate  # - \"feature_name\": gene name  req_cols = c(\"x\",\"y\",\"feature_name\") cosmx_data = list(\"sample1\"= transcript_df[,c(req_cols)]) #   # clusters and cell locations  cl_req_cols = c(\"x\",\"y\",\"cluster\",\"sample\") clusters_df = clusters_info[,cl_req_cols]  # ----------------------------------------------------------------------------- # if available # define negative control objects if available # need to repeat for each background category and each sample # load coordinates for each detection, must contain following columns  # - \"x\": x coordinate # - \"y\": y coordinate  # - \"target\": negative control names  # - \"sample\": sample label  nc_coords = read.csv(\"./negative_controls_detections.csv\") nc_names = unique(nc_coords$feature_name) kpt_cols = c(\"x\",\"y\",\"feature_name\",\"sample\") nc_lst = list(\"sample1\"=nc_coords[,kpt_cols])"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-the-clusters-over-the-tissue-space","dir":"Articles","previous_headings":"Example","what":"Visualise the clusters over the tissue space","title":"jazzPanda example","text":"can plot cells coordinates cluster Replicate 1 subset","code":"p1<-ggplot(data = rep1_clusters,         aes(x = x, y = y, color=cluster))+         geom_point(position=position_jitterdodge(jitter.width=0,                                         jitter.height=0), size=0.1)+         scale_y_reverse()+         theme_classic()+         facet_wrap(~sample)+         scale_color_manual(values = c(\"#FC8D62\",\"#66C2A5\" ,\"#8DA0CB\",\"#E78AC3\",                         \"#A6D854\",\"skyblue\",\"purple3\",\"#E5C498\"))+         guides(color=guide_legend(title=\"cluster\", nrow = 2,                         override.aes=list(alpha=1, size=2)))+                  theme(axis.text.x=element_blank(),                 axis.text.y=element_blank(),                 axis.ticks=element_blank(),                 axis.title.x=element_blank(),                 axis.title.y=element_blank(),                 panel.spacing = unit(0.5, \"lines\"),                 legend.position=\"none\",                 strip.text = element_text(size = rel(1)))+         xlab(\"\")+         ylab(\"\") p2<-ggplot(data = rep1_clusters,         aes(x = x, y = y, color=cluster))+         geom_point(position=position_jitterdodge(jitter.width=0,                                      jitter.height=0), size=0.1)+         facet_wrap(~cluster, nrow = 2)+         scale_y_reverse()+         theme_classic()+         scale_color_manual(values = c(\"#FC8D62\",\"#66C2A5\" ,\"#8DA0CB\",\"#E78AC3\",                         \"#A6D854\",\"skyblue\",\"purple3\",\"#E5C498\"))+         guides(color=guide_legend(title=\"cluster\", nrow = 1,         override.aes=list(alpha=1, size=4)))+         theme(axis.text.x=element_blank(),             axis.text.y=element_blank(),             axis.ticks=element_blank(),             axis.title.x=element_blank(),             axis.title.y=element_blank(),             panel.spacing = unit(0.5, \"lines\"),              legend.text = element_text(size=10),             legend.position=\"none\",             legend.title = element_text(size=10),             strip.text = element_text(size = rel(1)))+         xlab(\"\")+         ylab(\"\")  spacer <- patchwork::plot_spacer() layout_design <- (p1 / spacer) | p2  layout_design <- layout_design +                      patchwork::plot_layout(widths = c(1, 4), heights = c(1, 1))   print(layout_design)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"spatial-vectors","dir":"Articles","previous_headings":"Example","what":"Spatial vectors","title":"jazzPanda example","text":"can visualize spatial vectors clusters genes follows. example creating spatial vectors genes, plot transcript detections gene EPCAM tissue space, along square hex binning result. Similarly, plot cell coordinates cluster c1, well square hex bin values space example. can see square hex bins capture key patterns original coordinates. Hex bins can capture details square bins.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"example-of-gene-vectors","dir":"Articles","previous_headings":"Example > Spatial vectors","what":"Example of gene vectors","title":"jazzPanda example","text":"","code":"w_x =  c(min(floor(min(rep1_sub$x)),         floor(min(rep1_clusters$x))),          max(ceiling(max(rep1_sub$x)),         ceiling(max(rep1_clusters$x)))) w_y =  c(min(floor(min(rep1_sub$y)),         floor(min(rep1_clusters$y))),          max(ceiling(max(rep1_sub$y)),         ceiling(max(rep1_clusters$y))))  # plot transcript detection coordinates selected_genes = rep1_sub$feature_name == \"EPCAM\" loc_mt = as.data.frame(rep1_sub[selected_genes,                         c(\"x\",\"y\",\"feature_name\")]%>%distinct()) colnames(loc_mt)=c(\"x\",\"y\",\"feature_name\") layout(matrix(c(1, 2, 3), 1, 3, byrow = TRUE)) par(mar=c(5,3,6,3)) plot(loc_mt$x, loc_mt$y, main = \"\", xlab = \"\", ylab = \"\",          pch = 20, col = \"maroon4\", cex = 0.1,xaxt='n', yaxt='n')    title(main = \"EPCAM transcript detection\", line = 3) box()   # plot square binning  curr<-loc_mt[loc_mt[,\"feature_name\"]==\"EPCAM\",c(\"x\",\"y\")] %>% distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, 10,10) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.01,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"square binning\", line = -2)  # plot hex binning  w <- owin(xrange=w_x, yrange=w_y) H <- hextess(W=w, 20) bin_length <- length(H$tiles) curr<-loc_mt[loc_mt[,\"feature_name\"]==\"EPCAM\",c(\"x\",\"y\")] %>% distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, tess=H) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.1,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"hex binning\", line = -2)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"example-of-cluster-vectors","dir":"Articles","previous_headings":"Example > Spatial vectors","what":"Example of cluster vectors","title":"jazzPanda example","text":"function get_vectors() can used create spatial vectors genes clusters. spatial vectors may take form squares, rectangles, hexagons specified bin_type parameter.","code":"w_x =  c(min(floor(min(rep1_sub$x)),             floor(min(rep1_clusters$x))),          max(ceiling(max(rep1_sub$x)),             ceiling(max(rep1_clusters$x)))) w_y =  c(min(floor(min(rep1_sub$y)),             floor(min(rep1_clusters$y))),          max(ceiling(max(rep1_sub$y)),             ceiling(max(rep1_clusters$y))))  # plot cell coordinates loc_mt = as.data.frame(rep1_clusters[rep1_clusters$cluster==\"c1\",             c(\"x\",\"y\",\"cluster\")]) colnames(loc_mt)=c(\"x\",\"y\",\"cluster\") layout(matrix(c(1, 2, 3), 1, 3, byrow = TRUE)) par(mar=c(5,3,6,3)) plot(loc_mt$x, loc_mt$y, main = \"\", xlab = \"\", ylab = \"\",          pch = 20, col = \"maroon4\", cex = 0.1,xaxt='n', yaxt='n')    title(main = \"cell coordinates in cluster c1\", line = 3) box()   # plot square binning  curr<-loc_mt[loc_mt[,\"cluster\"]==\"c1\", c(\"x\",\"y\")]%>%distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, 10,10) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.1,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"square binning\", line = -2)  # plot hex binning  w <- owin(xrange=w_x, yrange=w_y) H <- hextess(W=w, 20) bin_length <- length(H$tiles) curr<-loc_mt[loc_mt[,\"cluster\"]==\"c1\",c(\"x\",\"y\")] %>%distinct() curr_ppp <- ppp(curr$x,curr$y,w_x, w_y) vec_quadrat <- quadratcount(curr_ppp, tess=H) vec_its <- intensity(vec_quadrat, image=TRUE) par(mar=c(0.1,1, 1, 2)) plot(vec_its, main = \"\") title(main = \"hex binning\", line = -2)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"spatial-vectors-for-all-genes-and-clusters","dir":"Articles","previous_headings":"Example > Spatial vectors","what":"Spatial vectors for all genes and clusters","title":"jazzPanda example","text":"constructed spatial vectors can used quantify cluster-cluster gene-gene correlation.","code":"seed_number= 589  w_x =  c(min(floor(min(rep1_sub$x)),             floor(min(rep1_clusters$x))),          max(ceiling(max(rep1_sub$x)),             ceiling(max(rep1_clusters$x)))) w_y =  c(min(floor(min(rep1_sub$y)),             floor(min(rep1_clusters$y))),          max(ceiling(max(rep1_sub$y)),             ceiling(max(rep1_clusters$y))))  grid_length = 10 # get spatial vectors rep1_sq10_vectors = get_vectors(trans_lst= list(rep1_sub),                                 cluster_info = rep1_clusters,                                 bin_type=\"square\",                                 bin_param=c(grid_length,grid_length),                                  all_genes = all_real_genes ,                                  w_x=w_x, w_y=w_y)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"cluster-cluster-correlation","dir":"Articles","previous_headings":"Example > Spatial vectors > Spatial vectors for all genes and clusters","what":"Cluster-Cluster correlation","title":"jazzPanda example","text":"","code":"exp_ord = paste(\"c\", 1:8, sep=\"\") rep1_sq10_vectors$cluster_mt = rep1_sq10_vectors$cluster_mt[,exp_ord] cor_cluster_mt = cor(rep1_sq10_vectors$cluster_mt,                 rep1_sq10_vectors$cluster_mt, method = \"pearson\") # Calculate pairwise correlations cor_gene_mt = cor(rep1_sq10_vectors$gene_mt, rep1_sq10_vectors$gene_mt,                     method = \"pearson\")  col <- grDevices::colorRampPalette(c(\"#4477AA\", \"#77AADD\",                                      \"#FFFFFF\",\"#EE9988\", \"#BB4444\"))  corrplot::corrplot(cor_cluster_mt, method=\"color\", col=col(200), diag=TRUE,                 addCoef.col = \"black\",type=\"upper\",                 tl.col=\"black\", tl.srt=45, mar=c(0,0,5,0),sig.level = 0.05,                  insig = \"blank\",                  title = \"cluster-cluster correlation (square bin = 40x40)\"                 )"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"gene-cluster-correlation","dir":"Articles","previous_headings":"Example > Spatial vectors > Spatial vectors for all genes and clusters","what":"Gene-Cluster correlation","title":"jazzPanda example","text":"can also construct gene network based spatial vector genes.","code":"cor_genecluster_mt = cor(x=rep1_sq10_vectors$gene_mt,                          y=rep1_sq10_vectors$cluster_mt, method = \"pearson\")  gg_correlation = as.data.frame(cbind(apply(cor_gene_mt, MARGIN=1,                                              FUN = mean, na.rm=TRUE),                                         apply(cor_genecluster_mt, MARGIN=1,                                              FUN = mean, na.rm=TRUE))) colnames(gg_correlation) = c(\"mean_correlation\",\"mean_cluster\")   gg_correlation$gene=row.names(gg_correlation)  plot(ggplot(data = gg_correlation,      aes(x= mean_correlation, y=mean_cluster))+         geom_point()+         geom_text_repel(aes(label=gg_correlation$gene), size=1.8, hjust=1)+     theme_bw()+     theme(legend.title=element_blank(),             axis.text.y = element_text(size=20),             axis.text.x = element_text(size=20),             axis.title.x=element_text(size=20),             axis.title.y=element_text(size=20),              panel.spacing = unit(0.5, \"lines\"),              legend.position=\"none\",             legend.text=element_blank())+     xlab(\"Average gene-gene correlation\")+     ylab(\"Average gene-cluster correlation\"))"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"gene-network","dir":"Articles","previous_headings":"Example > Spatial vectors > Spatial vectors for all genes and clusters","what":"Gene network","title":"jazzPanda example","text":"","code":"vector_graph= igraph::graph_from_adjacency_matrix(cor_gene_mt,                                                 mode = \"undirected\",                                                  weighted = TRUE,                                                  diag = FALSE)  vector_graph=igraph::simplify(igraph::delete_edges(vector_graph,                          E(vector_graph)[abs(E(vector_graph)$weight) <= 0.7]))  layout=igraph::layout_with_kk(vector_graph)  # Plot the graph ggraph::ggraph(vector_graph, layout = layout) +     geom_edge_link(aes(edge_alpha = weight), show.legend = FALSE) +     geom_node_point(color = \"lightblue\", size = 5) +     geom_node_text(aes(label = name),                      vjust = 1, hjust = 1,size=2,color=\"orange\", repel = TRUE)"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"linear-relationship-between-markers-and-clusters","dir":"Articles","previous_headings":"Example","what":"Linear relationship between markers and clusters","title":"jazzPanda example","text":"assume relationship marker gene vector cluster spatial vector linear. several genes annotation panel.","code":"genes_lst = c(\"ERBB2\",\"AQP1\",\"LUM\",\"IL7R\",\"MZB1\")  for (i_cluster in c(\"c1\",\"c8\",\"c3\",\"c6\",\"c7\")){     cluster_vector=rep1_sq10_vectors$cluster_mt[,i_cluster]          data_vis=as.data.frame(cbind(\"cluster\", cluster_vector,                             rep1_sq10_vectors$gene_mt[, genes_lst]))          colnames(data_vis)=c(\"cluster\",\"cluster_vector\",genes_lst)     data_vis=reshape2::melt(data_vis,variable.name = \"genes\",                             value.name = \"gene_vector\",                             id= c(\"cluster\",\"cluster_vector\" ))     data_vis$cluster_vector=as.numeric(data_vis$cluster_vector)     data_vis$genes=factor(data_vis$genes)     data_vis$gene_vector=as.numeric(data_vis$gene_vector)          plot(ggplot(data = data_vis,              aes(x= cluster_vector, y=gene_vector))+             geom_point(size=0.1)+             facet_wrap(~genes,scales = \"free_y\", ncol=10)+             theme_bw()+             theme(legend.title=element_blank(),                 axis.text.y = element_text(size=6),                 axis.text.x = element_text(size=6,angle=0),                 axis.title.x=element_text(size=10),                 axis.title.y=element_text(size=10),                  panel.spacing = unit(0.5, \"lines\"),                  legend.position=\"none\",                 legend.text=element_blank(),                 strip.text = element_text(size = rel(1)))+                 xlab(paste(i_cluster,\" - cluster vector\", sep=\"\"))+                 ylab(\"gene vector\")) }"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"scenario-1-one-sample","dir":"Articles","previous_headings":"Example","what":"Scenario 1: one sample","title":"jazzPanda example","text":"straightforward approach identifying genes exhibit linear correlation cluster vectors involves computing Pearson correlation gene every cluster. assess statistical significance correlations, compute_permp() function can used perform permutation testing, generating p-value every pair gene cluster cluster vector.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"correlation-based-method-to-detect-marker-genes","dir":"Articles","previous_headings":"Example > Scenario 1: one sample","what":"Correlation-based method to detect marker genes","title":"jazzPanda example","text":"","code":"w_x =  c(min(floor(min(rep1_sub$x)),             floor(min(rep1_clusters$x))),          max(ceiling(max(rep1_sub$x)),             ceiling(max(rep1_clusters$x)))) w_y =  c(min(floor(min(rep1_sub$y)),             floor(min(rep1_clusters$y))),          max(ceiling(max(rep1_sub$y)),             ceiling(max(rep1_clusters$y)))) set.seed(seed_number) perm_p = compute_permp(data=list(rep1_sub),                         cluster_info=rep1_clusters,                          perm.size=1000,                         bin_type=\"square\",                         bin_param=c(10,10),                         all_genes= all_real_genes,                         correlation_method = \"pearson\",                          n.cores=1,                          correction_method=\"BH\",                         w_x=w_x ,                         w_y=w_y)  # observed correlation for every pair of gene and cluster vector obs_corr = as.data.frame(perm_p$obs.stat) head(obs_corr) ##                c5          c8         c3         c2          c1         c4 ## LUM   -0.08301696  0.13734641  0.8724430 -0.4389799 -0.46034377  0.1823640 ## CD68  -0.26037887  0.06259766  0.2360819 -0.4126090 -0.02885842  0.5951329 ## ERBB2  0.08159437 -0.34437593 -0.5542681  0.6259111  0.69027586 -0.3613350 ## MZB1  -0.13221192  0.11731624  0.1781597 -0.1148358 -0.25954267  0.4160637 ## EPCAM -0.11473423 -0.35287011 -0.5724549  0.3454557  0.86438353 -0.3496045 ## PTPRC -0.15420177  0.23596298  0.2773785 -0.2801968 -0.37755016  0.8048566 ##               c6         c7 ## LUM    0.2118598  0.1531026 ## CD68   0.2343318  0.1504930 ## ERBB2 -0.4587071 -0.4455121 ## MZB1   0.5952111  0.8168198 ## EPCAM -0.4591613 -0.4444322 ## PTPRC  0.9455237  0.7628466 # permutation adjusted p-value for every pair of gene and cluster vector perm_res = as.data.frame(perm_p$perm.pval.adj) head(perm_res) ##       c5         c8          c3         c2          c1          c4          c6 ## LUM    1 0.05661006 0.006660007 1.00000000 1.000000000 0.002854289 0.003996004 ## CD68   1 0.74592075 0.199800200 1.00000000 1.000000000 0.002854289 0.064550834 ## ERBB2  1 1.00000000 1.000000000 0.00999001 0.003996004 1.000000000 1.000000000 ## MZB1   1 0.82346225 0.736186890 1.00000000 1.000000000 0.007992008 0.002497502 ## EPCAM  1 1.00000000 1.000000000 0.10389610 0.003996004 1.000000000 1.000000000 ## PTPRC  1 0.66533467 0.736186890 1.00000000 1.000000000 0.002854289 0.002497502 ##                c7 ## LUM   0.047452547 ## CD68  0.263372991 ## ERBB2 1.000000000 ## MZB1  0.003330003 ## EPCAM 1.000000000 ## PTPRC 0.003330003"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-top-marker-genes-detected-by-correlation-approach","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Correlation-based method to detect marker genes","what":"Visualise top marker genes detected by correlation approach","title":"jazzPanda example","text":"Genes significant adjusted p-value considered marker genes corresponding cluster. can rank marker genes observed correlationand plot transcript detection coordinates top three marker genes every cluster.","code":"res_df_1000=as.data.frame(perm_p$perm.pval.adj) res_df_1000$gene=row.names(res_df_1000) cluster_names = unique(as.character(rep1_clusters$cluster)) for (cl in cluster_names){     perm_sig = res_df_1000[res_df_1000[,cl]<0.05,]     # define a cutoff value based on 75% quantile      obs_cutoff = quantile(obs_corr[, cl], 0.75)     perm_cl=intersect(row.names(perm_res[perm_res[,cl]<0.05,]),                         row.names(obs_corr[obs_corr[, cl]>obs_cutoff,]))     inters=perm_cl     rounded_val=signif(as.numeric(obs_corr[inters,cl]), digits = 3)     inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value = as.numeric(inters_df$value)     inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df = inters_df[1:min(nrow(inters_df),2),]     inters_df$text= paste(inters_df$gene,inters_df$value,sep=\": \")     curr_genes = rep1_sub$feature_name %in% inters_df$gene     data_vis =rep1_sub[curr_genes, c(\"x\",\"y\",\"feature_name\")]     data_vis$text = inters_df[match(data_vis$feature_name,inters_df$gene),                                 \"text\"]     data_vis$text = factor(data_vis$text, levels=inters_df$text)     p1<-ggplot(data = data_vis,                 aes(x = x, y = y))+                 geom_point(size=0.01,color=\"maroon4\")+                 facet_wrap(~text,ncol=10, scales=\"free\")+                 scale_y_reverse()+                 guides(fill = guide_colorbar(height= unit(5, \"cm\")))+                 defined_theme     cl_pt<-ggplot(data = rep1_clusters[rep1_clusters$cluster==cl, ],                     aes(x = x, y = y, color=cluster))+                     geom_point(position=position_jitterdodge(jitter.width=0,                                              jitter.height=0), size=0.2)+                     facet_wrap(~cluster)+                     scale_y_reverse()+                     theme_classic()+                     scale_color_manual(values = \"black\")+                     defined_theme     lyt <- cl_pt | p1     layout_design <- lyt + patchwork::plot_layout(widths = c(1,3))      print(layout_design) }"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-cluster-vector-and-the-top-marker-genes-at-spatial-vector-level","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Correlation-based method to detect marker genes","what":"Visualise cluster vector and the top marker genes at spatial vector level","title":"jazzPanda example","text":"check linear relationship cluster vector marker gene vectors, can plot cluster vector x-axis, marker gene vector y-axis. figure shows relationship cluster vector top marker gene vectors detected correlation approach. method identify linearly correlated genes cluster construct linear model gene. can use lasso_markers function get relevant cluster label every gene.","code":"cluster_names = paste(\"c\", 1:8, sep=\"\") plot_lst=list() for (cl in cluster_names){     perm_sig = res_df_1000[res_df_1000[,cl]<0.05,]     curr_cell_type = all_celltypes[all_celltypes$cluster==cl,\"anno\"]     obs_cutoff = quantile(obs_corr[, cl], 0.75)     perm_cl=intersect(row.names(perm_res[perm_res[,cl]<0.05,]),                         row.names(obs_corr[obs_corr[, cl]>obs_cutoff,]))     inters=perm_cl     rounded_val=signif(as.numeric(obs_corr[inters,cl]), digits = 3)     inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value = as.numeric(inters_df$value)     inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text= paste(inters_df$gene,inters_df$value,sep=\": \")     mk_gene = inters_df[1:min(2, nrow(inters_df)),\"gene\"]     if (length(mk_gene > 0)){         dff = as.data.frame(cbind(rep1_sq10_vectors$cluster_mt[,cl],                                     rep1_sq10_vectors$gene_mt[,mk_gene]))         colnames(dff) = c(\"cluster\", mk_gene)                  dff$vector_id = c(1:(grid_length * grid_length))         long_df <- dff %>%          pivot_longer(cols = -c(cluster, vector_id), names_to = \"gene\",                                  values_to = \"vector_count\")         long_df$gene = factor(long_df$gene, levels=mk_gene)                  p=ggplot(long_df, aes(x = cluster, y = vector_count )) +             geom_point( size=0.01) +             facet_wrap(~gene, scales = \"free_y\", nrow=1) +             labs(x = paste(\"cluster vector \", curr_cell_type, sep=\"\"),                      y = \"marker gene vectors\") +             theme_minimal()+             guides(color=guide_legend(nrow = 1,                         override.aes=list(alpha=1, size=2)))+             theme(panel.grid = element_blank(),legend.position = \"none\",                     strip.text = element_text(size = rel(1)),                     axis.line=element_blank(),                     legend.title = element_blank(),                     legend.key.size = unit(0.5, \"cm\"),                     legend.text = element_text(size=10),                     axis.text=element_blank(),                     axis.ticks=element_blank(),                     axis.title=element_text(size = 10),                     panel.border =element_rect(colour = \"black\",                                                  fill=NA, linewidth=0.5)             )         plot_lst[[cl]] = p     } } combined_plot <- ggarrange(plotlist = plot_lst,                              ncol = 2, nrow = 4,                             common.legend = FALSE, legend = \"none\")  combined_plot"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"linear-modeling-approach-to-detect-marker-genes","dir":"Articles","previous_headings":"Example > Scenario 1: one sample","what":"Linear modeling approach to detect marker genes","title":"jazzPanda example","text":"can create spatial vectors negative control genes include background noise “clusters”.","code":"probe_nm = unique(rep1_neg[rep1_neg$category==\"probe\",\"feature_name\"]) codeword_nm = unique(rep1_neg[rep1_neg$category==\"codeword\",\"feature_name\"]) rep1_nc_vectors = create_genesets(data_lst=list(\"rep1\"= rep1_neg),                                     name_lst=list(probe=probe_nm,                                                  codeword=codeword_nm),                                      bin_type=\"square\",                                     bin_param=c(10, 10),                                      w_x=w_x, w_y=w_y,                                     cluster_info = NULL)  set.seed(seed_number)  rep1_lasso_with_nc = lasso_markers(gene_mt=rep1_sq10_vectors$gene_mt,                                     cluster_mt = rep1_sq10_vectors$cluster_mt,                                     sample_names=c(\"rep1\"),                                     keep_positive=TRUE,                                      coef_cutoff=0.2,                                     background=rep1_nc_vectors)  rep1_top_df_nc = rep1_lasso_with_nc$lasso_top_result # the top result table  head(rep1_top_df_nc) ##        gene top_cluster  glm_coef   pearson max_gg_corr max_gc_corr ## LUM     LUM          c3 15.181040 0.8724430   0.9115601   0.8724430 ## CD68   CD68          c4  4.468619 0.5951329   0.5143408   0.5951329 ## ERBB2 ERBB2          c1 14.508203 0.6902759   0.8864028   0.6902759 ## MZB1   MZB1          c7  3.020872 0.8168198   0.7963419   0.8168198 ## EPCAM EPCAM          c1 10.590911 0.8643835   0.9547929   0.8643835 ## PTPRC PTPRC          c6  3.620975 0.9455237   0.8794803   0.9455237 # the full result table  rep1_full_df = rep1_lasso_with_nc$lasso_full_result head(rep1_full_df) ##      gene cluster glm_coef      p_value   pearson max_gg_corr max_gc_corr ## 50   AQP1      c8 6.998951 3.650999e-25 0.8270796   0.8442294   0.8270796 ## 51   AQP1      c6 1.702569 9.317924e-05 0.3209543   0.8442294   0.8270796 ## 52   AQP1      c3 1.013530 2.956703e-03 0.2099349   0.8442294   0.8270796 ## 57 CCDC80      c3 3.920877 2.448703e-21 0.7163637   0.8086714   0.7163637 ## 58 CCDC80      c7 1.583871 2.963857e-02 0.2349379   0.8086714   0.7163637 ## 2    CD68      c4 4.468619 2.344267e-11 0.5951329   0.5143408   0.5951329"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-top-marker-genes-detected-by-linear-modelling-approach","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Linear modeling approach to detect marker genes","what":"Visualise top marker genes detected by linear modelling approach","title":"jazzPanda example","text":"can rank marker genes linear model coefficient cluster ans plot transcript detection coordinates top three marker genes every cluster.","code":"cluster_names = paste(\"c\", 1:8, sep=\"\") for (cl in setdiff(cluster_names,\"NoSig\")){     inters=rep1_top_df_nc[rep1_top_df_nc$top_cluster==cl,\"gene\"]     rounded_val=signif(as.numeric(rep1_top_df_nc[inters,\"glm_coef\"]),                                     digits = 3)     inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value = as.numeric(inters_df$value)     inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text= paste(inters_df$gene,inters_df$value,sep=\": \")          if (length(inters > 0)){         inters_df = inters_df[1:min(2, nrow(inters_df)),]         inters = inters_df$gene         iters_rep1= rep1_sub$feature_name %in% inters         vis_r1 =rep1_sub[iters_rep1,                                 c(\"x\",\"y\",\"feature_name\")]         vis_r1$value = inters_df[match(vis_r1$feature_name,inters_df$gene),                                 \"value\"]         #vis_r1=vis_r1[order(vis_r1$value,decreasing = TRUE),]         vis_r1$text_label= paste(vis_r1$feature_name,                                     vis_r1$value,sep=\": \")         vis_r1$text_label=factor(vis_r1$text_label, levels = inters_df$text)         vis_r1$sample=\"rep1\"         p1<- ggplot(data = vis_r1,                     aes(x = x, y = y))+                      geom_point(size=0.01,color=\"maroon4\")+                     facet_wrap(~text_label,ncol=10, scales=\"free\")+                     scale_y_reverse()+                     guides(fill = guide_colorbar(height= unit(5, \"cm\")))+                     defined_theme         cl_pt<-ggplot(data = rep1_clusters[rep1_clusters$cluster==cl, ],                     aes(x = x, y = y, color=cluster))+                     geom_point(position=position_jitterdodge(jitter.width=0,                                              jitter.height=0), size=0.2)+                     facet_wrap(~cluster)+                     scale_y_reverse()+                     theme_classic()+                     scale_color_manual(values = \"black\")+                     defined_theme         lyt <- cl_pt | p1         layout_design <- lyt + patchwork::plot_layout(widths = c(1,3))          print(layout_design) }}"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-cluster-vector-and-the-top-marker-genes-at-spatial-vector-level-1","dir":"Articles","previous_headings":"Example > Scenario 1: one sample > Linear modeling approach to detect marker genes","what":"Visualise cluster vector and the top marker genes at spatial vector level","title":"jazzPanda example","text":"can plot cluster vector x-axis, marker gene vectors (detected linear modelling approach) y-axis validate linear relationship assumption cluster vector marker gene vectors.","code":"cluster_names = paste(\"c\", 1:8, sep=\"\") plot_lst=list() for (cl in cluster_names){     curr_cell_type = all_celltypes[all_celltypes$cluster==cl,\"anno\"]     inters=rep1_top_df_nc[rep1_top_df_nc$top_cluster==cl,\"gene\"]     if (length(inters > 0)){         rounded_val=signif(as.numeric(rep1_top_df_nc[inters,\"glm_coef\"]),                                 digits = 3)         inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))         inters_df$value = as.numeric(inters_df$value)         inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]         inters_df$text= paste(inters_df$gene,inters_df$value,sep=\": \")              inters_df = inters_df[1:min(2, nrow(inters_df)),]         mk_gene = inters_df$gene          dff = as.data.frame(cbind(rep1_sq10_vectors$cluster_mt[,cl],                                 rep1_sq10_vectors$gene_mt[,mk_gene]))         colnames(dff) = c(\"cluster\", mk_gene)         dff$vector_id = c(1:(grid_length * grid_length))         long_df <- dff %>%          pivot_longer(cols = -c(cluster, vector_id), names_to = \"gene\",                          values_to = \"vector_count\")         long_df$gene = factor(long_df$gene, levels=mk_gene)         p=ggplot(long_df, aes(x = cluster, y = vector_count )) +             geom_point( size=0.01) +             facet_wrap(~gene, scales = \"free_y\", nrow=1) +             labs(x = paste(\"cluster vector \", curr_cell_type, sep=\"\"),                      y = \"marker gene vectors\") +             theme_minimal()+             guides(color=guide_legend(nrow = 1,                         override.aes=list(alpha=1, size=2)))+             theme(panel.grid = element_blank(),legend.position = \"none\",                     strip.text = element_text(size = rel(1)),                     axis.line=element_blank(),                     legend.title = element_blank(),                     legend.key.size = unit(0.5, \"cm\"),                     legend.text = element_text(size=10),                     axis.text=element_blank(),                     axis.ticks=element_blank(),                     axis.title=element_text(size = 10),                     panel.border =element_rect(colour = \"black\",                                                  fill=NA, linewidth=0.5)         )         plot_lst[[cl]] = p     } } combined_plot <- ggarrange(plotlist = plot_lst,                              ncol = 2, nrow = 4,                             common.legend = FALSE, legend = \"none\")  combined_plot"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"scenario-2-multiple-samples","dir":"Articles","previous_headings":"Example","what":"Scenario 2: multiple samples","title":"jazzPanda example","text":"Load replicate 2 sample 1.","code":"data(rep2_sub, rep2_clusters, rep2_neg) rep2_clusters$cluster=factor(rep2_clusters$cluster,                             levels=paste(\"c\",1:8, sep=\"\")) rep1_clusters$cells = paste(row.names(rep1_clusters),\"_1\",sep=\"\") rep2_clusters$cells =paste(row.names(rep2_clusters),\"_2\",sep=\"\") rep_clusters = rbind(rep1_clusters,rep2_clusters) rep_clusters$cluster=factor(rep_clusters$cluster,                             levels=paste(\"c\",1:8, sep=\"\")) table(rep_clusters$sample, rep_clusters$cluster) ##        ##         c1  c2  c3  c4  c5  c6  c7  c8 ##   rep1 745 205 221 127  87 176  45  99 ##   rep2  27 476 313 190 360 256  99  94"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-the-clusters","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples","what":"Visualise the clusters","title":"jazzPanda example","text":"can plot coordinates cells every cluster every replicate  multiple replicates dataset, can find marker genes providing additional sample information input function lasso_markers.","code":"ggplot(data = rep_clusters,         aes(x = x, y = y, color=cluster))+         geom_point(position=position_jitterdodge(jitter.width=0,                                                  jitter.height=0),size=0.1)+         facet_grid(sample~cluster)+         scale_y_reverse()+         theme_classic()+         scale_color_manual(values = c(\"#FC8D62\",\"#66C2A5\" ,\"#8DA0CB\",\"#E78AC3\",                                 \"#A6D854\",\"skyblue\",\"purple3\",\"#E5C498\"))+         guides(color=guide_legend(title=\"cluster\", nrow = 1,         override.aes=list(alpha=1, size=7)))+         theme(             axis.line=element_blank(),             axis.text.x=element_blank(),             axis.text.y=element_blank(),             axis.ticks=element_blank(),             axis.title.x=element_blank(),             axis.title.y=element_blank(),             panel.background=element_blank(),             panel.border=element_blank(),             panel.grid.major=element_blank(),             panel.grid.minor=element_blank(),             plot.background=element_blank(),             legend.text = element_text(size=10),             legend.position=\"none\",             legend.title = element_text(size=10),             strip.text = element_text(size = rel(1)))+         xlab(\"\")+         ylab(\"\")"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"linear-modeling-approach-to-detect-marker-genes-1","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples","what":"Linear modeling approach to detect marker genes","title":"jazzPanda example","text":"","code":"w_x =  c(min(floor(min(rep1_sub$x)),             floor(min(rep2_sub$x)),             floor(min(rep_clusters$x))),          max(ceiling(max(rep1_sub$x)),             ceiling(max(rep2_sub$x)),             ceiling(max(rep_clusters$x)))) w_y =  c(min(floor(min(rep1_sub$y)),             floor(min(rep2_sub$y)),             floor(min(rep_clusters$y))),          max(ceiling(max(rep1_sub$y)),             ceiling(max(rep2_sub$y)),             ceiling(max(rep_clusters$y)))) grid_length=10 # get spatial vectors two_rep_vectors = get_vectors(trans_lst= list(\"rep1\"=rep1_sub,                                              \"rep2\" = rep2_sub),                             cluster_info = rep_clusters, bin_type=\"square\",                             bin_param=c(grid_length, grid_length),                             all_genes = all_real_genes ,                              w_x=w_x, w_y=w_y) probe_nm = unique(rep1_neg[rep1_neg$category==\"probe\",\"feature_name\"]) codeword_nm = unique(rep1_neg[rep1_neg$category==\"probe\",\"feature_name\"])  two_rep_nc_vectors = create_genesets(data_lst=list(\"rep1\" = rep1_neg,                                                      \"rep2\" = rep2_neg),                                         name_lst=list(probe=probe_nm,                                                      codeword=codeword_nm),                                         bin_type=\"square\",                                         bin_param=c(10,10),                                          w_x=w_x, w_y=w_y,                                         cluster_info = NULL) set.seed(seed_number) two_rep_lasso_with_nc = lasso_markers(gene_mt=two_rep_vectors$gene_mt,                                     cluster_mt = two_rep_vectors$cluster_mt,                                     sample_names=c(\"rep1\",\"rep2\"),                                     keep_positive=TRUE,                                      coef_cutoff=0.2,                                     background=two_rep_nc_vectors,n_fold = 5) tworep_res=two_rep_lasso_with_nc$lasso_top_result tworep_res$celltype = rep_clusters[match(tworep_res$top_cluster,                                             rep_clusters$cluster),\"anno\"] table(tworep_res$top_cluster) ##  ## c1 c2 c3 c4 c5 c6 c7 c8  ##  3  2  3  3  2  2  2  3 head(tworep_res) ##        gene top_cluster  glm_coef   pearson max_gg_corr max_gc_corr    celltype ## LUM     LUM          c3 12.252136 0.8838826   0.9150385   0.8838826     Stromal ## CD68   CD68          c4  2.820226 0.6902781   0.6540004   0.6902781 Macrophages ## ERBB2 ERBB2          c2 21.723376 0.7811584   0.9072989   0.7811584        DCIS ## MZB1   MZB1          c7  2.806131 0.7500983   0.7879303   0.7500983     B_Cells ## EPCAM EPCAM          c1  9.271843 0.6247635   0.9398823   0.6247635       Tumor ## PTPRC PTPRC          c6  3.446430 0.9170205   0.8945435   0.9170205     T_Cells"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-the-top-marker-genes-for-each-cluster","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples > Linear modeling approach to detect marker genes","what":"Visualise the top marker genes for each cluster","title":"jazzPanda example","text":"","code":"for (cl in all_celltypes$anno){     inters=tworep_res[tworep_res$celltype==cl,\"gene\"]     rounded_val=signif(as.numeric(tworep_res[inters,\"glm_coef\"]),                         digits = 3)     inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value = as.numeric(inters_df$value)     inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text= paste(inters_df$gene,inters_df$value,sep=\": \")     if (length(inters > 0)){         inters_df = inters_df[1:min(2, nrow(inters_df)),]         inters = inters_df$gene         iters_rep1= rep1_sub$feature_name %in% inters         vis_r1 =rep1_sub[iters_rep1,                                 c(\"x\",\"y\",\"feature_name\")]         vis_r1$value = inters_df[match(vis_r1$feature_name,inters_df$gene),                                 \"value\"]         vis_r1=vis_r1[order(vis_r1$value,decreasing = TRUE),]         vis_r1$text_label= paste(vis_r1$feature_name,                                     vis_r1$value,sep=\": \")         vis_r1$text_label=factor(vis_r1$text_label)         vis_r1$sample=\"rep1\"         iters_rep2= rep2_sub$feature_name %in% inters         vis_r2 =rep2_sub[iters_rep2,                                 c(\"x\",\"y\",\"feature_name\")]         vis_r2$value = inters_df[match(vis_r2$feature_name,inters_df$gene),                                 \"value\"]         vis_r2=vis_r2[order(vis_r2$value, decreasing = TRUE),]         vis_r2$text_label= paste(vis_r2$feature_name,                                 vis_r2$value,sep=\": \")         vis_r2$text_label=factor(vis_r2$text_label)         vis_r2$sample=\"rep2\"         p1<- ggplot(data = vis_r1,                     aes(x = x, y = y))+                      geom_point(size=0.01,color=\"maroon4\")+                     facet_grid(sample~text_label, scales=\"free\")+                     scale_y_reverse()+                     guides(fill = guide_colorbar(height= unit(5, \"cm\")))+                     defined_theme         p2<- ggplot(data = vis_r2,                     aes(x = x, y = y))+                      geom_point(size=0.01,color=\"maroon4\")+                     facet_grid(sample~text_label,scales=\"free\")+                     scale_y_reverse()+                     guides(fill = guide_colorbar(height= unit(5, \"cm\")))+                     defined_theme                  cl_pt<-ggplot(data = rep_clusters[rep_clusters$anno==cl, ],                     aes(x = x, y = y, color=cluster))+                     geom_point(position=position_jitterdodge(jitter.width=0,                                              jitter.height=0), size=0.2)+                     facet_grid(sample~cluster)+                     scale_y_reverse()+                     theme_classic()+                     scale_color_manual(values = \"black\")+                     defined_theme         lyt <- cl_pt | (p1 / p2)          if (cl %in% c(\"c6\",\"c7\")){             lyt <- cl_pt | ((p1 / p2) | patchwork::plot_spacer())            }         layout_design <- lyt + patchwork::plot_layout(widths = c(1,3))           print(layout_design) }}"},{"path":"https://phipsonlab.github.io/jazzPanda/articles/jazzPanda.html","id":"visualise-cluster-vector-and-the-top-marker-genes-at-spatial-vector-level-2","dir":"Articles","previous_headings":"Example > Scenario 2: multiple samples > Linear modeling approach to detect marker genes","what":"Visualise cluster vector and the top marker genes at spatial vector level","title":"jazzPanda example","text":"figure shows relationship cluster vector top marker gene vectors detected linear modelling approach accounting multiple samples background noise","code":"cluster_names = paste(\"c\", 1:8, sep=\"\") plot_lst=list() for (cl in cluster_names){     inters=tworep_res[tworep_res$top_cluster==cl,\"gene\"]     curr_cell_type = all_celltypes[all_celltypes$cluster==cl,\"anno\"]     rounded_val=signif(as.numeric(tworep_res[inters,\"glm_coef\"]),                             digits = 3)     inters_df = as.data.frame(cbind(gene=inters, value=rounded_val))     inters_df$value = as.numeric(inters_df$value)     inters_df=inters_df[order(inters_df$value, decreasing = TRUE),]     inters_df$text= paste(inters_df$gene,inters_df$value,sep=\": \")              mk_gene = inters_df[1:min(2, nrow(inters_df)),\"gene\"]     if (length(inters > 0)){         dff = as.data.frame(cbind(two_rep_vectors$cluster_mt[,cl],                                     two_rep_vectors$gene_mt[,mk_gene]))         colnames(dff) = c(\"cluster\", mk_gene)         total_tiles = grid_length * grid_length         dff$vector_id = c(1:total_tiles)         dff$sample= \"Replicate1\"         dff[(total_tiles+1):(total_tiles*2),\"sample\"] = \"Replicate2\"         dff$vector_id = c(1:total_tiles, 1:total_tiles)         long_df <- dff %>%          pivot_longer(cols = -c(cluster, sample, vector_id), names_to = \"gene\",                          values_to = \"vector_count\")         long_df$gene = factor(long_df$gene, levels=mk_gene)         p=ggplot(long_df,                          aes(x = cluster, y = vector_count, color =sample)) +             geom_point( size=0.01) +             facet_wrap(~gene, scales = \"free_y\", nrow=1) +             labs(x = paste(\"cluster vector \", curr_cell_type, sep=\"\"),                      y = \"marker gene vectors\") +             theme_minimal()+             guides(color=guide_legend(nrow = 1,                         override.aes=list(alpha=1, size=2)))+             theme(panel.grid = element_blank(),legend.position = \"bottom\",                     strip.text = element_text(size = rel(1)),                     axis.line=element_blank(),                     legend.title = element_blank(),                     legend.key.size = unit(0.5, \"cm\"),                     legend.text = element_text(size=10),                     axis.text=element_blank(),                     axis.ticks=element_blank(),                     axis.title=element_text(size = 10),                     panel.border =element_rect(colour = \"black\",                                                  fill=NA, linewidth=0.5)             )         plot_lst[[cl]] = p     } } combined_plot <- ggarrange(plotlist = plot_lst,                              ncol = 2, nrow = 4,                             common.legend = TRUE, legend = \"top\")  combined_plot sessionInfo() ## R version 4.4.2 (2024-10-31) ## Platform: x86_64-pc-linux-gnu ## Running under: Ubuntu 22.04.5 LTS ##  ## Matrix products: default ## BLAS:   /usr/lib/x86_64-linux-gnu/openblas-pthread/libblas.so.3  ## LAPACK: /usr/lib/x86_64-linux-gnu/openblas-pthread/libopenblasp-r0.3.20.so;  LAPACK version 3.10.0 ##  ## locale: ##  [1] LC_CTYPE=C.UTF-8       LC_NUMERIC=C           LC_TIME=C.UTF-8        ##  [4] LC_COLLATE=C.UTF-8     LC_MONETARY=C.UTF-8    LC_MESSAGES=C.UTF-8    ##  [7] LC_PAPER=C.UTF-8       LC_NAME=C              LC_ADDRESS=C           ## [10] LC_TELEPHONE=C         LC_MEASUREMENT=C.UTF-8 LC_IDENTIFICATION=C    ##  ## time zone: UTC ## tzcode source: system (glibc) ##  ## attached base packages: ## [1] stats     graphics  grDevices utils     datasets  methods   base      ##  ## other attached packages: ##  [1] ggpubr_0.6.0           tidyr_1.3.1            spatstat_3.2-1         ##  [4] spatstat.linnet_3.2-2  spatstat.model_3.3-2   rpart_4.1.23           ##  [7] spatstat.explore_3.3-3 nlme_3.1-166           spatstat.random_3.3-2  ## [10] spatstat.geom_3.3-3    spatstat.univar_3.1-1  spatstat.data_3.1-2    ## [13] gridExtra_2.3          ggrepel_0.9.6          ggraph_2.2.1           ## [16] igraph_2.1.1           corrplot_0.95          caret_6.0-94           ## [19] lattice_0.22-6         glmnet_4.1-8           Matrix_1.7-1           ## [22] dplyr_1.1.4            data.table_1.16.2      jazzPanda_0.99.0       ## [25] ggplot2_3.5.1          Seurat_5.1.0           SeuratObject_5.0.2     ## [28] sp_2.1-4               ##  ## loaded via a namespace (and not attached): ##   [1] RcppAnnoy_0.0.22      splines_4.4.2         later_1.3.2           ##   [4] tibble_3.2.1          polyclip_1.10-7       hardhat_1.4.0         ##   [7] pROC_1.18.5           fastDummies_1.7.4     lifecycle_1.0.4       ##  [10] rstatix_0.7.2         doParallel_1.0.17     globals_0.16.3        ##  [13] MASS_7.3-61           backports_1.5.0       magrittr_2.0.3        ##  [16] plotly_4.10.4         sass_0.4.9            rmarkdown_2.29        ##  [19] jquerylib_0.1.4       yaml_2.3.10           httpuv_1.6.15         ##  [22] sctransform_0.4.1     spam_2.11-0           spatstat.sparse_3.1-0 ##  [25] reticulate_1.39.0     cowplot_1.1.3         pbapply_1.7-2         ##  [28] RColorBrewer_1.1-3    lubridate_1.9.3       abind_1.4-8           ##  [31] Rtsne_0.17            purrr_1.0.2           nnet_7.3-19           ##  [34] tweenr_2.0.3          ipred_0.9-15          lava_1.8.0            ##  [37] irlba_2.3.5.1         listenv_0.9.1         spatstat.utils_3.1-1  ##  [40] goftest_1.2-3         RSpectra_0.16-2       fitdistrplus_1.2-1    ##  [43] parallelly_1.39.0     pkgdown_2.1.1         leiden_0.4.3.1        ##  [46] codetools_0.2-20      ggforce_0.4.2         tidyselect_1.2.1      ##  [49] shape_1.4.6.1         farver_2.1.2          viridis_0.6.5         ##  [52] matrixStats_1.4.1     stats4_4.4.2          jsonlite_1.8.9        ##  [55] Formula_1.2-5         tidygraph_1.3.1       progressr_0.15.0      ##  [58] ggridges_0.5.6        survival_3.7-0        iterators_1.0.14      ##  [61] systemfonts_1.1.0     foreach_1.5.2         tools_4.4.2           ##  [64] ragg_1.3.3            ica_1.0-3             Rcpp_1.0.13-1         ##  [67] glue_1.8.0            prodlim_2024.06.25    xfun_0.49             ##  [70] mgcv_1.9-1            withr_3.0.2           fastmap_1.2.0         ##  [73] fansi_1.0.6           digest_0.6.37         timechange_0.3.0      ##  [76] R6_2.5.1              mime_0.12             textshaping_0.4.0     ##  [79] colorspace_2.1-1      scattermore_1.2       tensor_1.5            ##  [82] utf8_1.2.4            generics_0.1.3        recipes_1.1.0         ##  [85] class_7.3-22          graphlayouts_1.2.0    httr_1.4.7            ##  [88] htmlwidgets_1.6.4     uwot_0.2.2            ModelMetrics_1.2.2.2  ##  [91] pkgconfig_2.0.3       gtable_0.3.6          timeDate_4041.110     ##  [94] lmtest_0.9-40         htmltools_0.5.8.1     carData_3.0-5         ##  [97] dotCall64_1.2         scales_1.3.0          png_0.1-8             ## [100] gower_1.0.1           knitr_1.49            reshape2_1.4.4        ## [103] cachem_1.1.0          zoo_1.8-12            stringr_1.5.1         ## [106] KernSmooth_2.23-24    parallel_4.4.2        miniUI_0.1.1.1        ## [109] desc_1.4.3            pillar_1.9.0          grid_4.4.2            ## [112] vctrs_0.6.5           RANN_2.6.2            promises_1.3.0        ## [115] car_3.1-3             xtable_1.8-4          cluster_2.1.6         ## [118] evaluate_1.0.1        cli_3.6.3             compiler_4.4.2        ## [121] rlang_1.1.4           ggsignif_0.6.4        future.apply_1.11.3   ## [124] labeling_0.4.3        plyr_1.8.9            fs_1.6.5              ## [127] stringi_1.8.4         viridisLite_0.4.2     deldir_2.0-4          ## [130] BiocParallel_1.40.0   munsell_0.5.1         lazyeval_0.2.2        ## [133] RcppHNSW_0.6.0        patchwork_1.3.0       future_1.34.0         ## [136] shiny_1.9.1           ROCR_1.0-11           broom_1.0.7           ## [139] memoise_2.0.1         bslib_0.8.0"},{"path":"https://phipsonlab.github.io/jazzPanda/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Melody Jin. Author, maintainer.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Jin M (2024). jazzPanda: Finding spatially relevant marker genes image based spatial transcriptomics data. R package version 0.99.0, https://bhuvad.github.io/jazzPanda/, https://github.com/phipsonlab/jazzPanda.","code":"@Manual{,   title = {jazzPanda: Finding spatially relevant marker genes in image based spatial transcriptomics data},   author = {Melody Jin},   year = {2024},   note = {R package version 0.99.0, https://bhuvad.github.io/jazzPanda/},   url = {https://github.com/phipsonlab/jazzPanda}, }"},{"path":"https://phipsonlab.github.io/jazzPanda/index.html","id":"introduction","dir":"","previous_headings":"","what":"Introduction","title":"Finding spatially relevant marker genes in image based spatial transcriptomics data","text":"jazzPanda package contains functions find marker genes based spatial coordinates imaging-based spatial transcriptomics technologies including 10x Xenium, NanoString CosMx Vizgen MERSCOPE.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Finding spatially relevant marker genes in image based spatial transcriptomics data","text":"currently process submitting jazzPanda Bioconductor. install jazzPanda github, use following commands: order view vignette jazzPanda use following command:","code":"library(devtools) devtools::install_github(\"phipsonlab/jazzPanda\") browseVignettes(\"jazzPanda\")"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_binning.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to check the input of binning — check_binning","title":"helper function to check the input of binning — check_binning","text":"helper function check input binning","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_binning.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to check the input of binning — check_binning","text":"","code":"check_binning(bin_param, bin_type, w_x, w_y)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_binning.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to check the input of binning — check_binning","text":"bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_binning.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to check the input of binning — check_binning","text":"length total bins","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_geneset_input.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to check the inputs passed to create geneset function — check_geneset_input","title":"helper function to check the inputs passed to create geneset function — check_geneset_input","text":"helper function check inputs passed create geneset function","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_geneset_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to check the inputs passed to create geneset function — check_geneset_input","text":"","code":"check_geneset_input(data_lst, bin_type, bin_param, w_x, w_y, cluster_info)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_geneset_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to check the inputs passed to create geneset function — check_geneset_input","text":"data_lst list named matrices containing coordinates transcripts count matrix. transcript coordinates provided, spatial vectors created directly transcript coordinates given set genes. case, every matrix must contain \"x\", \"y\", \"feature_name\" columns. list count matrices provided, spatial vectors defined cell coordinates count matrix. second case, parameter `cluster_info` must specified provide cell coordinates. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box. cluster_info `data_lst` contains transcript coordinates, parameter must set NULL. `data_lst` contains count matrix, `cluster_info` dataframe/matrix containing centroid coordinates, cluster sample label cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample).","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_geneset_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to check the inputs passed to create geneset function — check_geneset_input","text":"list two elements","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_valid_input.html","id":null,"dir":"Reference","previous_headings":"","what":"helper function to check the inputs passed to marker detection function — check_valid_input","title":"helper function to check the inputs passed to marker detection function — check_valid_input","text":"helper function check inputs passed marker detection function","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_valid_input.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"helper function to check the inputs passed to marker detection function — check_valid_input","text":"","code":"check_valid_input(   gene_mt,   cluster_mt,   sample_names,   n_fold = 10,   background = NULL )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_valid_input.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"helper function to check the inputs passed to marker detection function — check_valid_input","text":"gene_mt matrix contains transcript count grid. row refers grid, column refers gene. column names must specified refer genes. can output function get_vectors. cluster_mt matrix contains number cells specific cluster grid. row refers grid, column refers cluster. column names must specified refer clusters. Please assign integers column names. can output function get_vectors. sample_names vector specifying names samples. n_fold Optional. positive number giving number folds used cross validation. parameter pass cv.glmnet calculate penalty term every gene. background Optional. matrix providing background information. row refers grid, column refers one category background information. Number rows must equal number rows gene_mt cluster_mt. Can obtained providing coordinates matrices cluster_info. function get_vectors.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/check_valid_input.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"helper function to check the inputs passed to marker detection function — check_valid_input","text":"list two matrices following components n_clusters Number clusters cluster_names vector strings giving name clusters","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_observation.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute observation statistic for permutation framework — compute_observation","title":"Compute observation statistic for permutation framework — compute_observation","text":"Compute observation statistic permutation framework","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_observation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute observation statistic for permutation framework — compute_observation","text":"","code":"compute_observation(   data,   cluster_info,   correlation_method = \"pearson\",   all_genes = all_genes,   bin_type,   bin_param,   w_x,   w_y )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_observation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute observation statistic for permutation framework — compute_observation","text":"data list matrices containing coordinates transcripts. cluster_info dataframe/matrix containing centroid coordinates cluster label cell.column names include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label). correlation_method parameter pass cor, indicating correlation coefficient computed. One \"pearson\" (default), \"kendall\", \"spearman\": can abbreviated. all_genes vector strings giving name genes want test correlation . bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_observation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute observation statistic for permutation framework — compute_observation","text":"named list following components obs.stat matrix contains observation statistic every gene every cluster. row refers gene, column refers cluster gene_mt contains transcript count grid. row refers grid, column refers gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate a p-value for correlation with permutation. — compute_permp","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"function run permutation framework compute p-value correlation vectorised genes clusters cluster one sample.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"","code":"compute_permp(   data,   cluster_info,   perm.size,   bin_type,   bin_param,   all_genes,   correlation_method = \"pearson\",   n.cores = 1,   correction_method = \"BH\",   w_x,   w_y )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"data list matrices containing coordinates transcripts. cluster_info dataframe/matrix containing centroid coordinates cluster label cell.column names include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label). perm.size positive number specifying permutation times bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . all_genes vector strings giving name genes want test correlation . gene_mt. correlation_method parameter pass cor indicating correlation coefficient computed. One \"pearson\" (default), \"kendall\", \"spearman\": can abbreviated. n.cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing). correction_method character string pass p.adjust specifying correction method multiple testing . w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"named list following components obs.stat matrix contains observation statistic every gene every cluster. row refers gene, column refers cluster perm.arrays three dimensional array. first two dimensions represent correlation genes permuted clusters. third dimension refers different permutation runs. perm.pval matrix contains raw permutation p-value. row refers gene, column refers cluster perm.pval.adj matrix contains adjusted permutation p-value. row refers gene, column refers cluster","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"get permutation p-value correlation gene cluster, function permute cluster label cell randomly, calculate correlation genes permuted clusters. process repeated perm.size times, permutation p-value calculated probability permuted correlations larger observation correlation.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permp.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate a p-value for correlation with permutation. — compute_permp","text":"","code":"set.seed(100) # simulate coordinates for clusters df_clA = data.frame(x = rnorm(n=100, mean=20, sd=5),                    y = rnorm(n=100, mean=20, sd=5), cluster=\"A\") df_clB = data.frame(x = rnorm(n=100, mean=100, sd=5),                   y = rnorm(n=100, mean=100, sd=5), cluster=\"B\") clusters = rbind(df_clA, df_clB) clusters$sample=\"rep1\" # simulate coordinates for genes trans_info = data.frame(rbind(cbind(x = rnorm(n=100, mean=20, sd=5),                                     y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A1\"),                            cbind(x = rnorm(n=100, mean=20, sd=5),                                  y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A2\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B1\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B2\"))) trans_info$x=as.numeric(trans_info$x) trans_info$y=as.numeric(trans_info$y) w_x =  c(min(floor(min(trans_info$x)),             floor(min(clusters$x))),         max(ceiling(max(trans_info$x)),             ceiling(max(clusters$x)))) w_y =  c(min(floor(min(trans_info$y)),          floor(min(clusters$y))),       max(ceiling(max(trans_info$y)),           ceiling(max(clusters$y))))            perm_res_lst = compute_permp(data=list(\"sample1\"=trans_info),                     cluster_info=clusters,                     perm.size=100,                     bin_type=\"square\",                     bin_param=c(2,2),                     all_genes=unique(trans_info$feature_name),                     correlation_method = \"pearson\",                     n.cores=2,                     correction_method=\"BH\",                     w_x=w_x ,                     w_y=w_y) #> Correlation Method = pearson #> Running 100 permutation with 2 cores in parallel perm_pvalue = perm_res_lst$perm.pval.adj"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permutation.html","id":null,"dir":"Reference","previous_headings":"","what":"Compute permutation statistics for permutation framework — compute_permutation","title":"Compute permutation statistics for permutation framework — compute_permutation","text":"Compute permutation statistics permutation framework","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permutation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Compute permutation statistics for permutation framework — compute_permutation","text":"","code":"compute_permutation(   cluster_info,   perm.size = 1000,   correlation_method = \"pearson\",   bin_type,   bin_param,   n.cores = 1,   w_x,   w_y,   gene_mt,   cluster_names )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permutation.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Compute permutation statistics for permutation framework — compute_permutation","text":"cluster_info dataframe/matrix containing centroid coordinates cluster label cell.column names include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label). perm.size positive number specifying permutation times correlation_method parameter pass cor, indicating correlation coefficient computed. One \"pearson\" (default), \"kendall\", \"spearman\": can abbreviated. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . n.cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing). w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box. gene_mt matrix contains transcript count grid. row refers grid, column refers gene. cluster_names list strings giving name order clusters","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/compute_permutation.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Compute permutation statistics for permutation framework — compute_permutation","text":"matrix permutation statistics","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/convert_data.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — convert_data","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — convert_data","text":"function takes object class SingleCellExperiment, SpatialExperiment SpatialFeatureExperimentreturns returns list object expected get_vector functions.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/convert_data.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — convert_data","text":"","code":"convert_data(x, sample_names)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/convert_data.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — convert_data","text":"x SingleCellExperiment SpatialExperiment SpatialFeatureExperiment object sample_names vector strings giving sample names","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/convert_data.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — convert_data","text":"outputs list object following components trans_lst list named dataframes. dataframe refers one sample shows transcript detection coordinates gene. name matches input sample_names cm_lst list named dataframes containing count matrix sample. name matches input sample_names","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/convert_data.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert SingleCellExperiment/SpatialExperiment/SpatialFeatureExperiment objects to list object for jazzPanda. — convert_data","text":"","code":"library(SingleCellExperiment) #> Loading required package: SummarizedExperiment #> Loading required package: MatrixGenerics #> Loading required package: matrixStats #>  #> Attaching package: ‘MatrixGenerics’ #> The following objects are masked from ‘package:matrixStats’: #>  #>     colAlls, colAnyNAs, colAnys, colAvgsPerRowSet, colCollapse, #>     colCounts, colCummaxs, colCummins, colCumprods, colCumsums, #>     colDiffs, colIQRDiffs, colIQRs, colLogSumExps, colMadDiffs, #>     colMads, colMaxs, colMeans2, colMedians, colMins, colOrderStats, #>     colProds, colQuantiles, colRanges, colRanks, colSdDiffs, colSds, #>     colSums2, colTabulates, colVarDiffs, colVars, colWeightedMads, #>     colWeightedMeans, colWeightedMedians, colWeightedSds, #>     colWeightedVars, rowAlls, rowAnyNAs, rowAnys, rowAvgsPerColSet, #>     rowCollapse, rowCounts, rowCummaxs, rowCummins, rowCumprods, #>     rowCumsums, rowDiffs, rowIQRDiffs, rowIQRs, rowLogSumExps, #>     rowMadDiffs, rowMads, rowMaxs, rowMeans2, rowMedians, rowMins, #>     rowOrderStats, rowProds, rowQuantiles, rowRanges, rowRanks, #>     rowSdDiffs, rowSds, rowSums2, rowTabulates, rowVarDiffs, rowVars, #>     rowWeightedMads, rowWeightedMeans, rowWeightedMedians, #>     rowWeightedSds, rowWeightedVars #> Loading required package: GenomicRanges #> Loading required package: stats4 #> Loading required package: BiocGenerics #>  #> Attaching package: ‘BiocGenerics’ #> The following objects are masked from ‘package:stats’: #>  #>     IQR, mad, sd, var, xtabs #> The following objects are masked from ‘package:base’: #>  #>     Filter, Find, Map, Position, Reduce, anyDuplicated, aperm, append, #>     as.data.frame, basename, cbind, colnames, dirname, do.call, #>     duplicated, eval, evalq, get, grep, grepl, intersect, is.unsorted, #>     lapply, mapply, match, mget, order, paste, pmax, pmax.int, pmin, #>     pmin.int, rank, rbind, rownames, sapply, saveRDS, setdiff, table, #>     tapply, union, unique, unsplit, which.max, which.min #> Loading required package: S4Vectors #>  #> Attaching package: ‘S4Vectors’ #> The following object is masked from ‘package:utils’: #>  #>     findMatches #> The following objects are masked from ‘package:base’: #>  #>     I, expand.grid, unname #> Loading required package: IRanges #> Loading required package: GenomeInfoDb #> Loading required package: Biobase #> Welcome to Bioconductor #>  #>     Vignettes contain introductory material; view with #>     'browseVignettes()'. To cite Bioconductor, see #>     'citation(\"Biobase\")', and for packages 'citation(\"pkgname\")'. #>  #> Attaching package: ‘Biobase’ #> The following object is masked from ‘package:MatrixGenerics’: #>  #>     rowMedians #> The following objects are masked from ‘package:matrixStats’: #>  #>     anyMissing, rowMedians library(SpatialExperiment) # A SingleCellExperiment object set.seed(200) counts_sp1 <- matrix(rpois(100, lambda = 10), ncol=10, nrow=10) counts_sp2 <- matrix(rpois(100, lambda = 5), ncol=10, nrow=10) sce <- SingleCellExperiment(list(sp1=counts_sp1, sp2=counts_sp2)) sce_example_lst <- convert_data(sce, sample_names = c(\"sp1\",\"sp2\"))  # A SpatialExperiment object n <- 10 y <- matrix(rpois(200, lambda = 2),nrow = n, ncol = 2*n) cd <- DataFrame(x = seq(2*n), y = seq(2*n)) spe1 <- SpatialExperiment(     assays = list(counts = y),     colData = cd,      sample_id=\"sample1\",     spatialCoordsNames = c(\"x\", \"y\")) se_example_lst <- convert_data(spe1, sample_names = c(\"sample1\")) ## Multiple sample scenario spe2 <- SpatialExperiment(     assays = list(counts = matrix(rpois(200, lambda = 2),                                   nrow = n, ncol = 2*n)),     colData = cd,      sample_id=\"sample2\",     spatialCoordsNames = c(\"x\", \"y\")) se_example_lst <- convert_data(cbind(spe1, spe2),                                 sample_names = c(\"sample1\", \"sample2\"))"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert the coordinates of set of genes into vectors. — create_genesets","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"Convert coordinates set genes vectors.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"","code":"create_genesets(   data_lst,   name_lst,   bin_type = \"square\",   bin_param,   w_x = w_x,   w_y = w_y,   cluster_info )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"data_lst list named matrices containing coordinates transcripts. name_lst named list strings giving name features treated background. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box. cluster_info dataframe/matrix containing centroid coordinates, cluster sample label cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample).","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"matrix contains sum count grid. row refers grid, column refers set name_lst. column name match names name_lst.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/create_genesets.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Convert the coordinates of set of genes into vectors. — create_genesets","text":"","code":"set.seed(15) trans = as.data.frame(rbind(cbind(x = runif(10, min=1, max=10),                                 y = runif(10, min=1, max=10),                                 feature_name=\"A\"),                          cbind(x = runif(5, min=10, max=24),                                y = runif(5, min=1, max=10),                                feature_name=\"B\"),                          cbind(x = runif(10, min=10, max=24),                                y = runif(10, min=10, max=24),                                feature_name=\"C\"))) trans$x = as.numeric(trans$x) trans$y = as.numeric(trans$y) geneset_res = create_genesets(data_lst=list(\"rep1\"= trans),                            name_lst=list(dummy_A=c(\"A\",\"C\"),                                          dummy_B=c(\"A\",\"B\",\"C\")),                            bin_type=\"square\",                            bin_param=c(2,2),                            w_x=c(0,25), w_y=c(0,25), cluster_info=NULL)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cluster_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial vectors for clusters — get_cluster_vectors","title":"Create spatial vectors for clusters — get_cluster_vectors","text":"Create spatial vectors clusters","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cluster_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial vectors for clusters — get_cluster_vectors","text":"","code":"get_cluster_vectors(cluster_info, bin_length, bin_type, bin_param, w_x, w_y)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cluster_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial vectors for clusters — get_cluster_vectors","text":"cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). bin_length positive integer giving length total bins bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_cluster_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial vectors for clusters — get_cluster_vectors","text":"matrix contains cell count grid. row refers grid, column refers cluster.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_cm.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial vectors for genes from count matrix and cell coordinates — get_gene_vectors_cm","title":"Create spatial vectors for genes from count matrix and cell coordinates — get_gene_vectors_cm","text":"function build gene vectors count matrix cell locations","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_cm.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial vectors for genes from count matrix and cell coordinates — get_gene_vectors_cm","text":"","code":"get_gene_vectors_cm(   cluster_info,   cm_lst,   bin_type,   bin_param,   all_genes,   w_x,   w_y )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_cm.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial vectors for genes from count matrix and cell coordinates — get_gene_vectors_cm","text":"cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). cm_lst list named matrices containing count matrix sample name must match sample column cluster_info. input provided, cluster_info must specified contain additional column \"cell_id\" link cell location count matrix. Default NULL. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . all_genes vector strings giving name genes want test. used column names one result matrix gene_mt. w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_cm.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial vectors for genes from count matrix and cell coordinates — get_gene_vectors_cm","text":"matrix contains transcript count grid. row refers grid, column refers gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_tr.html","id":null,"dir":"Reference","previous_headings":"","what":"Create spatial vectors for genes from transcript coordinates — get_gene_vectors_tr","title":"Create spatial vectors for genes from transcript coordinates — get_gene_vectors_tr","text":"function build gene vectors based transcript coordinates every gene","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_tr.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create spatial vectors for genes from transcript coordinates — get_gene_vectors_tr","text":"","code":"get_gene_vectors_tr(   trans_lst,   all_genes,   bin_type,   bin_param,   bin_length,   w_x,   w_y )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_tr.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create spatial vectors for genes from transcript coordinates — get_gene_vectors_tr","text":"trans_lst specified, list named dataframes. dataframe refers one sample shows transcript detection coordinates gene. Optional parameter. all_genes vector strings giving name genes want test. used column names one result matrix gene_mt. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . bin_length positive integer giving length total bins w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_gene_vectors_tr.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create spatial vectors for genes from transcript coordinates — get_gene_vectors_tr","text":"matrix contains transcript count grid. row refers grid, column refers gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_lasso_coef.html","id":null,"dir":"Reference","previous_headings":"","what":"help function to get lasso coefficient for every cluster for a given model — get_lasso_coef","title":"help function to get lasso coefficient for every cluster for a given model — get_lasso_coef","text":"help function get lasso coefficient every cluster given model","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_lasso_coef.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"help function to get lasso coefficient for every cluster for a given model — get_lasso_coef","text":"","code":"get_lasso_coef(   i_gene,   gene_mt,   vec_cluster,   cluster_names,   n_fold = 10,   n_samples,   sample_names )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_lasso_coef.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"help function to get lasso coefficient for every cluster for a given model — get_lasso_coef","text":"i_gene Name current gene gene_mt matrix contains transcript count grid. row refers grid, column refers gene. column names must specified refer genes. can output function get_vectors. vec_cluster matrix spatial vectors clusters. cluster_names vector strings giving name clusters n_fold Optional. positive number giving number folds used cross validation. parameter pass cv.glmnet calculate penalty term every gene. n_samples positive number giving number samples sample_names vector specifying names sample","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_lasso_coef.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"help function to get lasso coefficient for every cluster for a given model — get_lasso_coef","text":"list two matrices following components coef_df matrix giving lasso coefficient cluster lambda.1se lambda.1se value best fitted model","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":null,"dir":"Reference","previous_headings":"","what":"Vectorise the spatial coordinates — get_vectors","title":"Vectorise the spatial coordinates — get_vectors","text":"function convert coordinates numeric vector genes clusters.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Vectorise the spatial coordinates — get_vectors","text":"","code":"get_vectors(   trans_lst,   cluster_info,   cm_lst = NULL,   bin_type,   bin_param,   all_genes,   w_x,   w_y,   n_cores = 1 )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Vectorise the spatial coordinates — get_vectors","text":"trans_lst list list. Every nested list refers one sample, must contain least one matrix transcript coordinates. Optional parameter. cluster_info dataframe/matrix containing centroid coordinates, cluster label sample cell.column names must include \"x\" (x coordinate), \"y\" (y coordinate), \"cluster\" (cluster label) \"sample\" (sample). cm_lst list named matrices containing count matrix sample name must match sample column cluster_info. input provided, cluster_info must specified contain additional column \"cell_id\" link cell location count matrix. Default NULL. bin_type string indicating bin shape used vectorization. One \"square\" (default), \"rectangle\", \"hexagon\". bin_param numeric vector indicating size bin. bin_type \"square\" \"rectangle\", vector length two giving numbers rectangular quadrats x y directions. bin_type \"hexagonal\", number giving side length hexagons. Positive numbers . all_genes vector strings giving name genes want test. used column names one result matrix gene_mt. w_x numeric vector length two specifying x coordinate limits enclosing box. w_y numeric vector length two specifying y coordinate limits enclosing box. n_cores positive number specifying number cores used parallelizing permutation testing. Default one core (sequential processing).","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Vectorise the spatial coordinates — get_vectors","text":"list two matrices following components gene_mt contains transcript count grid. row refers grid, column refers gene. cluster_mt contains number cells specific cluster grid. row refers grid, column refers cluster. row order gene_mt matches row order cluster_mt.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Vectorise the spatial coordinates — get_vectors","text":"function can used generate input lasso_markers specifying parameters. Suppose input data contains \\(n\\) genes, \\(c\\) clusters, \\(k\\) samples, want use \\(\\times \\) square bin convert coordinates genes clusters 1d vectors. \\(k=1\\), returned list contain one matrix gene vectors (gene_mt) dimension \\(^2 \\times n\\) one matrix cluster vectors (cluster_mt) dimension \\(^2 \\times c\\). \\(k>1\\), gene cluster vectors constructed sample separately concat together. additional k columns returned cluster_mt, one-hot encoding sample information. Moreover, function can vectorise genes clusters separately based input. trans_lst NULL, function return vectorised clusters based cluster_info. cluster_info NULL, function return vectorised genes based trans_lst.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/get_vectors.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Vectorise the spatial coordinates — get_vectors","text":"","code":"# simulate coordinates for genes trans = as.data.frame(rbind(cbind(x = c(1,2,20,21,22,23,24),                                  y = c(23, 24, 1,2,3,4,5),                                  feature_name=\"A\"),                          cbind(x = c(1,20),                                y = c(15, 10),                                feature_name=\"B\"),                          cbind(x = c(1,2,20,21,22,23,24),                                y = c(23, 24, 1,2,3,4,5),                                feature_name=\"C\"))) trans$x = as.numeric(trans$x) trans$y = as.numeric(trans$y) clusters = data.frame(x = c(3, 5,11,21,2,23,19),                     y = c(20, 24, 1,2,3,4,5), cluster=\"cluster_1\") clusters$sample=\"rep1\" vecs_lst_gene = get_vectors(trans_lst= list(\"rep1\"= trans),                             cluster_info = clusters,                             bin_type = \"square\",                             bin_param = c(2,2),                             all_genes = c(\"A\",\"B\",\"C\"),                             w_x = c(0,25), w_y=c(0,25))   # generate gene vector from count matrix cm <- data.frame(rbind(\"gene_A\"=c(0,0,2,0,0,0,2),                      \"gene_B\"=c(5,3,3,13,0,1,14),                      \"gene_C\"=c(5,0,1,5,1,0,7),                      \"gene_D\"=c(0,1,1,2,0,0,2))) colnames(cm)= paste(\"cell_\", 1:7, sep=\"\") # simulate coordiantes for clusters clusters = data.frame(x = c(1, 2,20,21,22,23,24),             y = c(23, 24, 1,2,3,4,5), cluster=\"A\") clusters$sample=\"rep1\" clusters$cell_id= colnames(cm) vecs_lst = get_vectors(trans_lst= NULL, cluster_info = clusters,                         cm_lst=list(rep1=cm),                         bin_type = \"square\",                         bin_param = c(2,2),                         all_genes = row.names(cm),                         w_x = c(0,25), w_y=c(0,25))"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":null,"dir":"Reference","previous_headings":"","what":"Find marker genes with spatial coordinates — lasso_markers","title":"Find marker genes with spatial coordinates — lasso_markers","text":"function find spatially relevant cluster label gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Find marker genes with spatial coordinates — lasso_markers","text":"","code":"lasso_markers(   gene_mt,   cluster_mt,   sample_names,   keep_positive = TRUE,   coef_cutoff = 0.05,   background = NULL,   n_fold = 10 )"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Find marker genes with spatial coordinates — lasso_markers","text":"gene_mt matrix contains transcript count grid. row refers grid, column refers gene. column names must specified refer genes. can output function get_vectors. cluster_mt matrix contains number cells specific cluster grid. row refers grid, column refers cluster. column names must specified refer clusters. Please assign integers column names. can output function get_vectors. sample_names vector specifying names samples. keep_positive logical flag indicating whether return positively correlated clusters . coef_cutoff positive number giving coefficient cutoff value. Genes whose top cluster showing coefficient vlaue smaller cutoff . Default 0.05. background Optional. matrix providing background information. row refers grid, column refers one category background information. Number rows must equal number rows gene_mt cluster_mt. Can obtained providing coordinates matrices cluster_info. function get_vectors. n_fold Optional. positive number giving number folds used cross validation. parameter pass cv.glmnet calculate penalty term every gene.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Find marker genes with spatial coordinates — lasso_markers","text":"list two matrices following components lasso_top_result matrix detailed information gene relevant cluster label. gene Gene name top_cluster name revelant cluster thresholding coefficients. glm_coef coefficient selected cluster generalised linear model. pearson Pearson correlation gene vector selected cluster vector. max_gg_corr number showing maximum pearson correlation gene vector gene vectors input gene_mt max_gc_corr number showing maximum pearson correlation gene vector every cluster vectors input cluster_mt lasso_full_result matrix detailed information gene relevant cluster label. gene Gene name cluster name significant cluster glm_coef coefficient selected cluster generalised linear model. pearson Pearson correlation gene vector selected cluster vector. max_gg_corr number showing maximum pearson correlation gene vector gene vectors input gene_mt max_gc_corr number showing maximum pearson correlation gene vector every cluster vectors input cluster_mt","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Find marker genes with spatial coordinates — lasso_markers","text":"function take converted gene cluster vectors function get_vectors, return relevant cluster label gene. multiple samples dataset, function find shared markers across different samples including additional sample vectors input cluster_mt. function treats input cluster vectors features, create penalized linear model one gene vector lasso regularization. Clusters non-zero coefficient selected, clusters used formulate generalised linear model gene vector. input keep_positive TRUE, clusters positive coefficient significant p-value saved output matrix lasso_full_result. cluster positive coefficient minimum p-value regarded relevant cluster gene saved output matrix lasso_result. input keep_positive FALSE, clusters negative coefficient significant p-value saved output matrix lasso_full_result. cluster negative coefficient minimum p-value regarded relevant cluster gene saved output matrix lasso_result. clusters significant p-value, string \"NoSig\" returned gene. parameter background can used capture unwanted noise pattern dataset. example, can include negative control genes background cluster model. relevant cluster selected one gene matches background \"clusters\", return \"NoSig\" gene.","code":""},{"path":[]},{"path":"https://phipsonlab.github.io/jazzPanda/reference/lasso_markers.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Find marker genes with spatial coordinates — lasso_markers","text":"","code":"set.seed(100) #  simulate coordinates for clusters df_clA = data.frame(x = rnorm(n=100, mean=20, sd=5),                  y = rnorm(n=100, mean=20, sd=5), cluster=\"A\") df_clB = data.frame(x = rnorm(n=100, mean=100, sd=5),                 y = rnorm(n=100, mean=100, sd=5), cluster=\"B\")  clusters = rbind(df_clA, df_clB) clusters$sample=\"rep1\"  # simulate coordinates for genes trans_info = data.frame(rbind(cbind(x = rnorm(n=100, mean=20,sd=5),                                 y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A1\"),                            cbind(x = rnorm(n=100, mean=20, sd=5),                                  y = rnorm(n=100, mean=20, sd=5),                                  feature_name=\"gene_A2\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B1\"),                            cbind(x = rnorm(n=100, mean=100, sd=5),                                  y = rnorm(n=100, mean=100, sd=5),                                  feature_name=\"gene_B2\"))) trans_info$x=as.numeric(trans_info$x) trans_info$y=as.numeric(trans_info$y) w_x =  c(min(floor(min(trans_info$x)),          floor(min(clusters$x))),       max(ceiling(max(trans_info$x)),           ceiling(max(clusters$x)))) w_y =  c(min(floor(min(trans_info$y)),           floor(min(clusters$y))),       max(ceiling(max(trans_info$y)),           ceiling(max(clusters$y)))) vecs_lst = get_vectors(trans_lst=list(rep1=trans_info),                      cluster_info = clusters,                     bin_type = \"square\",                     bin_param = c(20,20),                     all_genes =c(\"gene_A1\",\"gene_A2\",\"gene_B1\",\"gene_B2\"),                     w_x = w_x, w_y=w_y) lasso_res = lasso_markers(gene_mt=vecs_lst$gene_mt,                         cluster_mt = vecs_lst$cluster_mt,                         sample_names=c(\"rep1\"),                         keep_positive=TRUE,                         coef_cutoff=0.05,                         background=NULL)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep1 selected cells — rep1_clusters","title":"Rep1 selected cells — rep1_clusters","text":"csv file containing coordinates cluster label cell selected subset rep1.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep1 selected cells — rep1_clusters","text":"","code":"data(rep1_clusters)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep1 selected cells — rep1_clusters","text":"data frame 1705 rows 6 variables: anno provided cell type annotation cluster cluster label x x coordinates y y coordiantes cells cell id sample sample id","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep1 selected cells — rep1_clusters","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep1/ Xenium_FFPE_Human_Breast_Cancer_Rep1_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep1 selected cells — rep1_clusters","text":"data frame","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep1 negative control genes within the selected region. — rep1_neg","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"data frame containing coordinates every negative control detection rep1","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"","code":"data(rep1_neg)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"data frame 237 rows 4 variables: x x coordinates y y coordiantes feature_name negative control probe name category negative control category","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep1/Xenium_FFPE_Human_Breast_ Cancer_Rep1_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_neg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep1 negative control genes within the selected region. — rep1_neg","text":"List","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"A small section of Xenium human breast cancer rep1. — rep1_sub","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"data frame containing coordinates every transcript","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"","code":"data(rep1_sub)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"data frame 79576 rows 3 variables: x x coordinates y y coordiantes feature_name transcript name","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep1/ Xenium_FFPE_Human_Breast_Cancer_Rep1_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep1_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A small section of Xenium human breast cancer rep1. — rep1_sub","text":"List","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep2 selected cells — rep2_clusters","title":"Rep2 selected cells — rep2_clusters","text":"csv file containing coordinates cluster label cell selected subset rep2.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep2 selected cells — rep2_clusters","text":"","code":"data(rep2_clusters)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep2 selected cells — rep2_clusters","text":"data frame 1815 rows 6 variables: anno provided cell type annotation cluster cluster label x x coordinates y y coordiantes cells cell id sample sample id","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep2 selected cells — rep2_clusters","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep2/ Xenium_FFPE_Human_Breast_Cancer_Rep2_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_clusters.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep2 selected cells — rep2_clusters","text":"data frame","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":null,"dir":"Reference","previous_headings":"","what":"Rep2 negative control genes within the selected region. — rep2_neg","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"data frame containing coordinates every negative control detection rep2","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"","code":"data(rep2_neg)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"data frame 98 rows 4 variables: x x coordinates y y coordiantes feature_name negative control probe name category negative control category","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep2/ Xenium_FFPE_Human_Breast_Cancer_Rep2_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_neg.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Rep2 negative control genes within the selected region. — rep2_neg","text":"List","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":null,"dir":"Reference","previous_headings":"","what":"A small section of Xenium human breast cancer rep2. — rep2_sub","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"small section Xenium human breast cancer rep2.","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"","code":"data(rep2_sub)"},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"data frame 90375 rows 3 variables: x x coordinates y y coordiantes feature_name transcript name","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"source","dir":"Reference","previous_headings":"","what":"Source","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"<https://cf.10xgenomics.com/samples/xenium/1.0.1/ Xenium_FFPE_Human_Breast_Cancer_Rep2/ Xenium_FFPE_Human_Breast_Cancer_Rep2_outs.zip>","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/reference/rep2_sub.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"A small section of Xenium human breast cancer rep2. — rep2_sub","text":"List","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-011","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.1.1","title":"jazzPanda 0.1.1","text":"Add convert_data() function expand interoperability Bioconductor. Support input objects SingleCellExperiment/SpatialExperimentSpatialFeatureExperiment class Modify one input type function get_vectors(). Renamed input parameter data_lst trans_lst specifically storing transcript coordinates .","code":""},{"path":"https://phipsonlab.github.io/jazzPanda/news/index.html","id":"jazzpanda-001","dir":"Changelog","previous_headings":"","what":"jazzPanda 0.0.1","title":"jazzPanda 0.0.1","text":"package renamed jazzPanda","code":""}]
